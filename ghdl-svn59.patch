diff -urN ghdl-0.24-orig/vhdl/disp_vhdl.adb ghdl-0.24/vhdl/disp_vhdl.adb
--- ghdl-0.24-orig/vhdl/disp_vhdl.adb	2005-10-08 14:29:56.000000000 +0200
+++ ghdl-0.24/vhdl/disp_vhdl.adb	2006-07-10 23:50:28.000000000 +0200
@@ -680,6 +680,8 @@
             Put ("variable ");
          when Iir_Kind_Constant_Interface_Declaration =>
             Put ("constant ");
+         when Iir_Kind_File_Interface_Declaration =>
+            Put ("file ");
          when others =>
             Error_Kind ("disp_interface_declaration", Inter);
       end case;
diff -urN ghdl-0.24-orig/vhdl/lang-specs.h ghdl-0.24/vhdl/lang-specs.h
--- ghdl-0.24-orig/vhdl/lang-specs.h	2005-02-27 18:00:59.000000000 +0100
+++ ghdl-0.24/vhdl/lang-specs.h	2006-07-10 23:50:25.000000000 +0200
@@ -22,7 +22,7 @@
 /* This is the contribution to the `default_compilers' array in gcc.c for
    GHDL.  */
 
-  {".vhd", "@vhdl", 0},
-  {".vhdl", "@vhdl", 0},
+  {".vhd", "@vhdl", 0, 0, 0},
+  {".vhdl", "@vhdl", 0, 0, 0},
   {"@vhdl",
-   "ghdl1 %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}", 0},
+   "ghdl1 %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}", 0, 0, 0},
diff -urN ghdl-0.24-orig/vhdl/Makefile.in ghdl-0.24/vhdl/Makefile.in
--- ghdl-0.24-orig/vhdl/Makefile.in	2006-06-25 06:42:09.000000000 +0200
+++ ghdl-0.24/vhdl/Makefile.in	2006-07-10 23:53:52.000000000 +0200
@@ -315,7 +315,7 @@
 	prev=`pwd`; cd $(SYN93_DIR); \
 	$(CP) ../ieee/ieee-obj93.cf .; \
 	test x$(VHDLLIBS_COPY_OBJS) = "xno" || \
-	for i in $(IEEE_SRCS) $(VITAL2000_SRCS); do \
+	for i in $(IEEE_SRCS) $(MATH_SRCS) $(VITAL2000_SRCS); do \
 	  b=`basename $$i .vhdl`; $(LN) ../ieee/$$b.o $$b.o || exit 1; \
 	done; \
 	for i in $(SYNOPSYS93_BSRCS); do \
@@ -330,7 +330,7 @@
 	prev=`pwd`; cd $(MENTOR93_DIR); \
 	$(CP) ../ieee/ieee-obj93.cf . ;\
 	test x$(VHDLLIBS_COPY_OBJS) = "xno" || \
-	for i in $(IEEE_SRCS) $(VITAL2000_SRCS); do \
+	for i in $(IEEE_SRCS) $(MATH_SRCS) $(VITAL2000_SRCS); do \
 	  b=`basename $$i .vhdl`; $(LN) ../ieee/$$b.o $$b.o || exit 1; \
 	done ; \
 	for i in $(MENTOR93_BSRCS); do \
diff -urN ghdl-0.24-orig/vhdl/scan-scan_literal.adb ghdl-0.24/vhdl/scan-scan_literal.adb
--- ghdl-0.24-orig/vhdl/scan-scan_literal.adb	2005-09-22 23:30:52.000000000 +0200
+++ ghdl-0.24/vhdl/scan-scan_literal.adb	2006-07-10 23:50:28.000000000 +0200
@@ -228,6 +228,8 @@
       Dividend : Uint16_Array (0 .. Nbr_Digits);
       A_F : constant Sint16 := First_Digit (A);
       B_F : constant Sint16 := First_Digit (B);
+
+      --  Digit corresponding to the first digit of B.
       Doff : constant Sint16 := Dividend'Last - B_F;
       Q : Uint16;
       C, N_C : Uint16;
@@ -238,6 +240,9 @@
       end if;
 
       --  Copy and shift dividend.
+      --  Bit 15 of the most significant digit of A becomes bit 0 of the
+      --  most significant digit of DIVIDEND.  Therefore we are sure
+      --  DIVIDEND < B (after realignment).
       C := 0;
       for K in 0 .. A_F loop
          N_C := Shift_Right (A.S (K), 15);
@@ -249,6 +254,7 @@
       Dividend (0 .. Dividend'last - 2 - A_F) := (others => 0);
 
       --  Algorithm is the same as division by hand.
+      C := 0;
       for I in reverse Digit_Range loop
          Q := 0;
          for J in 0 .. 15 loop
@@ -271,7 +277,13 @@
                   Tmp (K) := Dividend (Doff + K) - V16;
                end loop;
 
+               --  If the last shift creates a carry, we are sure Dividend > B
+               if C /= 0 then
+                  Borrow := 0;
+               end if;
+
                Q := Q * 2;
+               --  Begin of : Dividend = Dividend * 2
                C := 0;
                for K in 0 .. Doff - 1 loop
                   N_C := Shift_Right (Dividend (K), 15);
@@ -280,13 +292,17 @@
                end loop;
 
                if Borrow = 0 then
+                  --  Dividend > B
                   Q := Q + 1;
+                  --  Dividend = Tmp * 2
+                  --           = (Dividend - B) * 2
                   for K in Doff .. Nbr_Digits loop
                      N_C := Shift_Right (Tmp (K - Doff), 15);
                      Dividend (K) := Shift_Left (Tmp (K - Doff), 1) or C;
                      C := N_C;
                   end loop;
                else
+                  --  Dividend = Dividend * 2
                   for K in Doff .. Nbr_Digits loop
                      N_C := Shift_Right (Dividend (K), 15);
                      Dividend (K) := Shift_Left (Dividend (K), 1) or C;
diff -urN ghdl-0.24-orig/vhdl/translation.adb ghdl-0.24/vhdl/translation.adb
--- ghdl-0.24-orig/vhdl/translation.adb	2006-06-24 15:50:09.000000000 +0200
+++ ghdl-0.24/vhdl/translation.adb	2006-07-10 23:50:26.000000000 +0200
@@ -5082,14 +5082,16 @@
             return;
          end if;
 
+         Pkg := Get_Package (Decl);
+         Restore_Local_Identifier (Get_Info (Pkg).Package_Local_Id);
+         Chap4.Translate_Declaration_Chain (Decl);
+
          if Flag_Rti then
             Rtis.Generate_Unit (Decl);
          end if;
 
-         Pkg := Get_Package (Decl);
-         Restore_Local_Identifier (Get_Info (Pkg).Package_Local_Id);
-         Chap4.Translate_Declaration_Chain (Decl);
          Chap4.Translate_Declaration_Chain_Subprograms (Decl, Null_Iir);
+
          Elab_Package_Body (Pkg, Decl);
       end Translate_Package_Body;
 
@@ -25463,8 +25465,8 @@
                Generate_Declaration_Chain (Get_Declaration_Chain (Blk));
             when Iir_Kind_Package_Body =>
                Kind := Ghdl_Rtik_Package_Body;
-               -- FIXME: yes or not ?
-               --Generate_Declaration_Chain (Get_Declaration_Chain (Blk));
+               --  Required at least for 'image
+               Generate_Declaration_Chain (Get_Declaration_Chain (Blk));
             when Iir_Kind_Architecture_Declaration =>
                Kind := Ghdl_Rtik_Architecture;
                Generate_Declaration_Chain (Get_Declaration_Chain (Blk));
