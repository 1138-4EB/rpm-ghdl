diff -urN ghdl-0.26/vhdl/evaluation.adb ghdl-0.26dev/vhdl/evaluation.adb
--- ghdl-0.26/vhdl/evaluation.adb	2007-03-24 08:33:02.000000000 +0100
+++ ghdl-0.26dev/vhdl/evaluation.adb	2008-06-02 23:50:48.000000000 +0200
@@ -2020,6 +2020,10 @@
       --  Should check L <= R or L >= R according to direction.
       --return Eval_Is_In_Bound (Get_Left_Limit (A_Range), Sub_Type)
       --  and then Eval_Is_In_Bound (Get_Right_Limit (A_Range), Sub_Type);
+   exception
+      when Node_Error =>
+         --  Avoid error storms.
+         return True;
    end Eval_Is_Range_In_Bound;
 
    procedure Eval_Check_Range
@@ -2091,6 +2095,8 @@
             return Get_Physical_Value (Expr);
          when Iir_Kind_Unit_Declaration =>
             return Get_Value (Get_Physical_Unit_Value (Expr));
+         when Iir_Kind_Error =>
+            raise Node_Error;
          when others =>
             Error_Kind ("eval_pos", Expr);
       end case;
diff -urN ghdl-0.26/vhdl/grt/config/i386.S ghdl-0.26dev/vhdl/grt/config/i386.S
--- ghdl-0.26/vhdl/grt/config/i386.S	2005-09-23 00:39:19.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/config/i386.S	2008-06-02 23:50:39.000000000 +0200
@@ -21,21 +21,30 @@
 	
 	.text
 
-	/* Function called to loop on the process.  */	
-	.align 4
-	.type	grt_stack_loop,@function
-grt_stack_loop:	
+#ifdef __ELF__
+#define ENTRY(func) .align 4; .globl func; .type func,@function; func:
+#define END(func) .size func, . - func
+#define NAME(name) name
+#elif __APPLE__
+#define ENTRY(func) .align 4; .globl _##func; _##func:
+#define END(func)
+#define NAME(name) _##name
+#else
+#define ENTRY(func) .align 4; func:
+#define END(func)
+#define NAME(name) name
+#endif
+	
+	/* Function called to loop on the process.  */
+ENTRY(grt_stack_loop)
 	call	*4(%esp)
-	jmp	grt_stack_loop
-	.size	grt_stack_loop, . - grt_stack_loop
+	jmp	NAME(grt_stack_loop)
+END(grt_stack_loop)
 
 	/* function Stack_Create (Func : Address; Arg : Address)
  	                          return Stack_Type;
 	*/
-	.align	4
-	.globl grt_stack_create
-	.type	 grt_stack_create,@function
-grt_stack_create:
+ENTRY(grt_stack_create)
 	/* Standard prologue.  */
 	pushl	%ebp
 	movl	%esp,%ebp
@@ -43,7 +52,7 @@
 	subl	$8,%esp
 	
 	/* Allocate the stack, and exit in case of failure  */
-	call	grt_stack_allocate
+	call	NAME(grt_stack_allocate)
 	testl	%eax,%eax
 	je	.Ldone
 
@@ -58,7 +67,7 @@
 	movl	12(%ebp), %ecx
 	movl	%ecx, -8(%eax)
 	/* The return function.  */
-	movl	$grt_stack_loop, -12(%eax)
+	movl	$NAME(grt_stack_loop), -12(%eax)
 	/* The context.  */
 	movl	%ebx, -16(%eax)
 	movl	%esi, -20(%eax)
@@ -72,16 +81,12 @@
 .Ldone:
 	leave
 	ret
-	.size	 grt_stack_create,. - grt_stack_create
-
+END(grt_stack_create)
 
 
-	.align 4
-	.globl grt_stack_switch
 	/* Arguments:	TO, FROM
 	   Both are pointers to a stack_context.  */
-	.type	 grt_stack_switch,@function
-grt_stack_switch:
+ENTRY(grt_stack_switch)
 	/* TO -> ECX.  */
 	movl	4(%esp), %ecx
 	/* FROM -> EDX.  */
@@ -102,7 +107,7 @@
 	popl	%ebx
 	/* Run.  */
 	ret
-	.size	 grt_stack_switch, . - grt_stack_switch
+END(grt_stack_switch)
 
 	
 	.ident	"Written by T.Gingold"
diff -urN ghdl-0.26/vhdl/grt/config/linux.c ghdl-0.26dev/vhdl/grt/config/linux.c
--- ghdl-0.26/vhdl/grt/config/linux.c	2006-03-09 03:26:31.000000000 +0100
+++ ghdl-0.26dev/vhdl/grt/config/linux.c	2008-06-02 23:50:39.000000000 +0200
@@ -25,6 +25,10 @@
 #include <stdlib.h>
 //#include <stdint.h>
 
+#ifdef __APPLE__
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
 /* On x86, the stack growns downward.  */
 #define STACK_GROWNS_DOWNWARD 1
 
diff -urN ghdl-0.26/vhdl/grt/config/pthread.c ghdl-0.26dev/vhdl/grt/config/pthread.c
--- ghdl-0.26/vhdl/grt/config/pthread.c	2006-03-10 02:49:44.000000000 +0100
+++ ghdl-0.26dev/vhdl/grt/config/pthread.c	2008-06-02 23:50:39.000000000 +0200
@@ -28,6 +28,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <setjmp.h>
+#include <assert.h>
 
 //#define INFO printf
 #define INFO (void)
@@ -35,10 +36,14 @@
 // GHDL names an endless loop calling FUNC with ARG a 'stack'
 // at a given time, only one stack may be 'executed'
 typedef struct 
-{	pthread_t           thread;         // stack's thread
-	pthread_mutex_t     mutex;          // mutex to suspend/resume thread
-	void                (*Func)(void*); // stack's FUNC
-	void*               Arg;            // ARG passed to FUNC
+{	
+  pthread_t           thread;         // stack's thread
+  pthread_mutex_t     mutex;          // mutex to suspend/resume thread
+#if defined(__CYGWIN__)
+  pthread_mutexattr_t mxAttr;
+#endif
+  void                (*Func)(void*); // stack's FUNC
+  void*               Arg;            // ARG passed to FUNC
 } Stack_Type_t, *Stack_Type;
 
 static Stack_Type_t      main_stack_context;
@@ -51,40 +56,56 @@
 // This may adjust stack sizes.
 // Must be called after grt.options.decode.
 // => procedure Stack_Init;
-{	INFO("grt_stack_init\n");
-	INFO("  main_stack_context=0x%08x\n", &main_stack_context);
+{
+  int res;
+  INFO("grt_stack_init\n");
+  INFO("  main_stack_context=0x%08x\n", &main_stack_context);
 	
-	pthread_mutex_init(&(main_stack_context.mutex), NULL);
 
-	// lock the mutex, as we are currently running
-	pthread_mutex_lock(&(main_stack_context.mutex));
+#if defined(__CYGWIN__)
+  res = pthread_mutexattr_init (&main_stack_context.mxAttr);
+  assert (res == 0);
+  res = pthread_mutexattr_settype (&main_stack_context.mxAttr,
+				   PTHREAD_MUTEX_DEFAULT);
+  assert (res == 0);
+  res = pthread_mutex_init (&main_stack_context.mutex,
+			    &main_stack_context.mxAttr);
+  assert (res == 0);
+#else
+  res = pthread_mutex_init (&main_stack_context.mutex, NULL);
+  assert (res == 0);
+#endif
+  // lock the mutex, as we are currently running
+  res = pthread_mutex_lock (&main_stack_context.mutex);
+  assert (res == 0);
 	
-	current = &main_stack_context;
+  current = &main_stack_context;
 
-	grt_set_main_stack (&main_stack_context);
+  grt_set_main_stack (&main_stack_context);
 }
 
 //----------------------------------------------------------------------------
 static void* grt_stack_loop(void* pv_myStack)
 {
-	Stack_Type myStack= (Stack_Type)pv_myStack;
+  Stack_Type myStack= (Stack_Type)pv_myStack;
 
-	INFO("grt_stack_loop\n");
+  INFO("grt_stack_loop\n");
 	
-	INFO("  myStack=0x%08x\n", myStack);
+  INFO("  myStack=0x%08x\n", myStack);
 
-	// block until mutex becomes available again.
-	// this happens when this stack is enabled for the first time
-	pthread_mutex_lock(&(myStack->mutex));
+  // block until mutex becomes available again.
+  // this happens when this stack is enabled for the first time
+  pthread_mutex_lock(&(myStack->mutex));
 	
-	// run stack's function in endless loop
-	while(1)
-	{	INFO("  call 0x%08x with 0x%08x\n", myStack->Func, myStack->Arg);
-		myStack->Func(myStack->Arg);
-	}
+  // run stack's function in endless loop
+  while(1)
+    {
+      INFO("  call 0x%08x with 0x%08x\n", myStack->Func, myStack->Arg);
+      myStack->Func(myStack->Arg);
+    }
 	
-	// we never get here...
-	return 0;
+  // we never get here...
+  return 0;
 }
 
 //----------------------------------------------------------------------------
@@ -93,29 +114,41 @@
 // an argument ARG.
 // => function Stack_Create (Func : Address; Arg : Address) return Stack_Type;
 {
-  	Stack_Type newStack;
+  Stack_Type newStack;
+  int res;
 
-	INFO("grt_stack_create\n");
-	INFO("  call 0x%08x with 0x%08x\n", Func, Arg);
+  INFO("grt_stack_create\n");
+  INFO("  call 0x%08x with 0x%08x\n", Func, Arg);
 			
-	newStack= malloc(sizeof(Stack_Type_t));
+  newStack = malloc (sizeof(Stack_Type_t));
 	
-	// init function and argument
-	newStack->Func= Func;
-	newStack->Arg=  Arg;
+  // init function and argument
+  newStack->Func = Func;
+  newStack->Arg = Arg;
+	
+  // create mutex
+#if defined(__CYGWIN__)
+  res = pthread_mutexattr_init (&newStack->mxAttr);
+  assert (res == 0);
+  res = pthread_mutexattr_settype (&newStack->mxAttr, PTHREAD_MUTEX_DEFAULT);
+  assert (res == 0);
+  res = pthread_mutex_init (&newStack->mutex, &newStack->mxAttr);
+  assert (res == 0);
+#else
+  res = pthread_mutex_init (&newStack->mutex, NULL);
+  assert (res == 0);
+#endif
+	
+  // block the mutex, so that thread will blocked in grt_stack_loop
+  res = pthread_mutex_lock (&newStack->mutex);
+  assert (res == 0);
+  
+  INFO("  newStack=0x%08x\n", newStack);
 	
-	// create mutex
-	pthread_mutex_init(&(newStack->mutex), NULL);
+  // create thread, which executes grt_stack_loop
+  pthread_create (&newStack->thread, NULL, grt_stack_loop, newStack); 
 	
-	// block the mutex, so that thread will blocked in grt_stack_loop
-	pthread_mutex_lock(&(newStack->mutex));
-	
-	INFO("  newStack=0x%08x\n", newStack);
-	
-	// create thread, which executes grt_stack_loop
-	pthread_create(&(newStack->thread), NULL, grt_stack_loop, newStack); 
-	
-	return newStack;
+  return newStack;
 }
 
 static int need_longjmp;
@@ -127,30 +160,35 @@
 // Resume stack TO and save the current context to the stack pointed by
 // CUR.
 // => procedure Stack_Switch (To : Stack_Type; From : Stack_Type);
-{	INFO("grt_stack_switch\n");
-	INFO("  from 0x%08x to 0x%08x\n", From, To);
+{	
+  int res;
+  INFO("grt_stack_switch\n");
+  INFO("  from 0x%08x to 0x%08x\n", From, To);
 
-	current = To;
+  current = To;
 
-	// unlock 'To' mutex. this will make the other thread either
-	// - starts for first time in grt_stack_loop
-	// - resumes at lock below
-	pthread_mutex_unlock(&(To->mutex));
+  // unlock 'To' mutex. this will make the other thread either
+  // - starts for first time in grt_stack_loop
+  // - resumes at lock below
+  res = pthread_mutex_unlock (&To->mutex);
+  assert (res == 0);
 		
-	// block until 'From' mutex becomes available again
-	// as we are running, our mutex is locked and we block here
-	// when stacks are switched, with above unlock, we may proceed
-	pthread_mutex_lock(&(From->mutex));
+  // block until 'From' mutex becomes available again
+  // as we are running, our mutex is locked and we block here
+  // when stacks are switched, with above unlock, we may proceed
+  res = pthread_mutex_lock (&From->mutex);
+  assert (res == 0);
 
-	if (From == &main_stack_context && need_longjmp != 0)
-	  longjmp (run_env, need_longjmp);
+  if (From == &main_stack_context && need_longjmp != 0)
+    longjmp (run_env, need_longjmp);
 }
 
 //----------------------------------------------------------------------------
 void grt_stack_delete(Stack_Type Stack)
 // Delete stack STACK, which must not be currently executed.
 // => procedure Stack_Delete (Stack : Stack_Type);
-{	INFO("grt_stack_delete\n");
+{	
+  INFO("grt_stack_delete\n");
 }
 
 void
diff -urN ghdl-0.26/vhdl/grt/config/win32thr.c ghdl-0.26dev/vhdl/grt/config/win32thr.c
--- ghdl-0.26/vhdl/grt/config/win32thr.c	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-0.26dev/vhdl/grt/config/win32thr.c	2008-06-02 23:50:39.000000000 +0200
@@ -0,0 +1,167 @@
+/*  GRT stack implementation for Win32
+    Copyright (C) 2004, 2005 Felix Bertram.
+
+    GHDL is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+
+    GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the Free
+    Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+    02111-1307, USA.
+*/
+//-----------------------------------------------------------------------------
+// Project:     GHDL - VHDL Simulator
+// Description: Win32 port of stacks package
+// Note:        Tristan's original i386/Linux used assembly-code 
+//              to manually switch stacks for performance reasons.
+// History:     2004feb09, FB, created.
+//-----------------------------------------------------------------------------
+
+#include <windows.h>
+//#include <pthread.h>
+//#include <stdlib.h>
+//#include <stdio.h>
+
+
+//#define INFO printf
+#define INFO (void)
+
+// GHDL names an endless loop calling FUNC with ARG a 'stack'
+// at a given time, only one stack may be 'executed'
+typedef struct 
+{	HANDLE              thread;         // stack's thread
+	HANDLE              mutex;          // mutex to suspend/resume thread
+	void                (*Func)(void*); // stack's FUNC
+	void*               Arg;            // ARG passed to FUNC
+} Stack_Type_t, *Stack_Type;
+
+
+static Stack_Type_t      main_stack_context;
+extern void grt_set_main_stack (Stack_Type_t *stack);
+
+//------------------------------------------------------------------------------
+void grt_stack_init(void)
+// Initialize the stacks package.
+// This may adjust stack sizes.
+// Must be called after grt.options.decode.
+// => procedure Stack_Init;
+{	INFO("grt_stack_init\n");
+	INFO("  main_stack_context=0x%08x\n", &main_stack_context);
+
+	// create event. reset event, as we are currently running
+	main_stack_context.mutex = CreateEvent(NULL,  // lpsa
+	                                       FALSE, // fManualReset
+	                                       FALSE, // fInitialState
+	                                       NULL); // lpszEventName
+
+	grt_set_main_stack (&main_stack_context);
+}
+
+//------------------------------------------------------------------------------
+static unsigned long __stdcall grt_stack_loop(void* pv_myStack)
+{
+	Stack_Type myStack= (Stack_Type)pv_myStack;
+
+	INFO("grt_stack_loop\n");
+	
+	INFO("  myStack=0x%08x\n", myStack);
+
+	// block until event becomes set again.
+	// this happens when this stack is enabled for the first time
+	WaitForSingleObject(myStack->mutex, INFINITE);
+	
+	// run stack's function in endless loop
+	while(1)
+	{	INFO("  call 0x%08x with 0x%08x\n", myStack->Func, myStack->Arg);
+		myStack->Func(myStack->Arg);
+	}
+	
+	// we never get here...
+	return 0;
+}
+
+//------------------------------------------------------------------------------
+Stack_Type grt_stack_create(void* Func, void* Arg) 
+// Create a new stack, which on first execution will call FUNC with
+// an argument ARG.
+// => function Stack_Create (Func : Address; Arg : Address) return Stack_Type;
+{  	Stack_Type newStack;
+	DWORD      m_IDThread; // Thread's ID (dummy)
+
+	INFO("grt_stack_create\n");
+	INFO("  call 0x%08x with 0x%08x\n", Func, Arg);
+			
+	newStack= malloc(sizeof(Stack_Type_t));
+	
+	// init function and argument
+	newStack->Func= Func;
+	newStack->Arg=  Arg;
+	
+	// create event. reset event, so that thread will blocked in grt_stack_loop
+	newStack->mutex= CreateEvent(NULL,  // lpsa
+	                             FALSE, // fManualReset
+	                             FALSE, // fInitialState
+	                             NULL); // lpszEventName
+	
+	INFO("  newStack=0x%08x\n", newStack);
+	
+	// create thread, which executes grt_stack_loop
+	newStack->thread= CreateThread(NULL,           // lpsa
+	                               0,              // cbStack
+	                               grt_stack_loop, // lpStartAddr
+	                               newStack,       // lpvThreadParm
+	                               0,              // fdwCreate
+	                               &m_IDThread);   // lpIDThread
+	
+	return newStack;
+}
+
+//------------------------------------------------------------------------------
+void grt_stack_switch(Stack_Type To, Stack_Type From)
+// Resume stack TO and save the current context to the stack pointed by
+// CUR.
+// => procedure Stack_Switch (To : Stack_Type; From : Stack_Type);
+{	INFO("grt_stack_switch\n");
+	INFO("  from 0x%08x to 0x%08x\n", From, To);
+	
+	// set 'To' event. this will make the other thread either
+	// - start for first time in grt_stack_loop
+	// - resume at WaitForSingleObject below
+	SetEvent(To->mutex);
+		
+	// block until 'From' event becomes set again
+	// as we are running, our event is reset and we block here
+	// when stacks are switched, with above SetEvent, we may proceed
+	WaitForSingleObject(From->mutex, INFINITE);
+}
+
+//------------------------------------------------------------------------------
+void grt_stack_delete(Stack_Type Stack)
+// Delete stack STACK, which must not be currently executed.
+// => procedure Stack_Delete (Stack : Stack_Type);
+{	INFO("grt_stack_delete\n");
+}
+
+//----------------------------------------------------------------------------
+#ifndef WITH_GNAT_RUN_TIME
+void __gnat_raise_storage_error(void)
+{
+   abort ();
+}
+
+void __gnat_raise_program_error(void)
+{
+   abort ();
+}
+#endif
+
+//----------------------------------------------------------------------------
+// end of file
+
diff -urN ghdl-0.26/vhdl/grt/grt-avhpi.adb ghdl-0.26dev/vhdl/grt/grt-avhpi.adb
--- ghdl-0.26/vhdl/grt/grt-avhpi.adb	2006-07-29 21:51:22.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-avhpi.adb	2008-06-02 23:50:40.000000000 +0200
@@ -108,12 +108,17 @@
                when VhpiGenericDeclK =>
                   Res := (Kind => AvhpiNameIteratorK,
                           Ctxt => Ref.Ctxt,
-                          N_Addr => Loc_To_Addr (Ref.Obj.Common.Depth,
-                                                 Ref.Obj.Loc,
-                                                 Ref.Ctxt),
+                          N_Addr => Avhpi_Get_Address (Ref),
                           N_Type => Ref.Obj.Obj_Type,
                           N_Idx => 0,
                           N_Obj => Ref.Obj);
+               when VhpiIndexedNameK =>
+                  Res := (Kind => AvhpiNameIteratorK,
+                          Ctxt => Ref.Ctxt,
+                          N_Addr => Ref.N_Addr,
+                          N_Type => Ref.N_Type,
+                          N_Idx => 0,
+                          N_Obj => Ref.N_Obj);
                when others =>
                   Error := AvhpiErrorNotImplemented;
                   return;
@@ -143,16 +148,55 @@
       Error := AvhpiErrorNotImplemented;
    end Vhpi_Iterator;
 
+   --  OBJ_RTI is the RTI for the base name.
+   function Add_Index (Ctxt : Rti_Context;
+                       Obj_Base : Address;
+                       Obj_Rti : Ghdl_Rtin_Object_Acc;
+                       El_Type : Ghdl_Rti_Access;
+                       Off : Ghdl_Index_Type) return Address
+   is
+      Is_Sig : Boolean;
+      El_Size : Ghdl_Index_Type;
+      El_Type1 : Ghdl_Rti_Access;
+   begin
+      case Obj_Rti.Common.Kind is
+         when Ghdl_Rtik_Generic =>
+            Is_Sig := False;
+         when others =>
+            Internal_Error ("add_index");
+      end case;
+
+      if El_Type.Kind = Ghdl_Rtik_Subtype_Scalar then
+         El_Type1 := Get_Base_Type (El_Type);
+      else
+         El_Type1 := El_Type;
+      end if;
+
+      case El_Type1.Kind is
+         when Ghdl_Rtik_Type_P64 =>
+            if Is_Sig then
+               El_Size := Address'Size / Storage_Unit;
+            else
+               El_Size := Ghdl_I64'Size / Storage_Unit;
+            end if;
+         when Ghdl_Rtik_Subtype_Array =>
+            if Is_Sig then
+               El_Size :=
+                 To_Ghdl_Rtin_Subtype_Array_Acc (El_Type1).Sigsize.Off;
+            else
+               El_Size :=
+                 To_Ghdl_Rtin_Subtype_Array_Acc (El_Type1).Valsize.Off;
+            end if;
+         when others =>
+            Internal_Error ("add_index");
+      end case;
+      return Obj_Base + Off * El_Size;
+   end Add_Index;
+
    procedure Vhpi_Scan_Indexed_Name (Iterator : in out VhpiHandleT;
                                      Res : out VhpiHandleT;
                                      Error : out AvhpiErrorT)
    is
-      procedure Update (S : Ghdl_Index_Type) is
-      begin
-         Iterator.N_Addr := Iterator.N_Addr + (S / Storage_Unit);
-      end Update;
-
-      Is_Sig : Boolean;
       El_Type : Ghdl_Rti_Access;
    begin
       if Iterator.N_Idx = 0 then
@@ -171,23 +215,9 @@
               N_Obj => Iterator.N_Obj);
 
       --  Increment Address.
-      case Iterator.N_Obj.Common.Kind is
-         when Ghdl_Rtik_Generic =>
-            Is_Sig := False;
-         when others =>
-            Internal_Error ("vhpi_scan_indexed_name(1)");
-      end case;
+      Iterator.N_Addr := Add_Index
+        (Iterator.Ctxt, Iterator.N_Addr, Iterator.N_Obj, El_Type, 1);
 
-      case Get_Base_Type (El_Type).Kind is
-         when Ghdl_Rtik_Type_P64 =>
-            if Is_Sig then
-               Update (Address'Size);
-            else
-               Update (Ghdl_I64'Size);
-            end if;
-         when others =>
-            Internal_Error ("vhpi_scan_indexed_name");
-      end case;
       Iterator.N_Idx := Iterator.N_Idx - 1;
       Error := AvhpiErrorOk;
    end Vhpi_Scan_Indexed_Name;
@@ -328,12 +358,25 @@
                           Atype => Rti);
                end if;
             end;
+         when Ghdl_Rtik_Type_Array =>
+            Res := (Kind => VhpiArrayTypeDeclK,
+                    Ctxt => Ctxt,
+                    Atype => Rti);
          when Ghdl_Rtik_Type_B2
            | Ghdl_Rtik_Type_E8
            | Ghdl_Rtik_Type_E32 =>
             Res := (Kind => VhpiEnumTypeDeclK,
                     Ctxt => Ctxt,
                     Atype => Rti);
+         when Ghdl_Rtik_Type_P32
+           | Ghdl_Rtik_Type_P64 =>
+            Res := (Kind => VhpiPhysTypeDeclK,
+                    Ctxt => Ctxt,
+                    Atype => Rti);
+         when Ghdl_Rtik_Subtype_Scalar =>
+            Res := (Kind => VhpiSubtypeDeclK,
+                    Ctxt => Ctxt,
+                    Atype => Rti);
          when others =>
             Res := (Kind => VhpiUndefined,
                     Ctxt => Ctxt);
@@ -385,17 +428,19 @@
                when Ghdl_Rtik_Port
                  | Ghdl_Rtik_Generic
                  | Ghdl_Rtik_Signal
+                 | Ghdl_Rtik_Type_Array
                  | Ghdl_Rtik_Subtype_Array
                  | Ghdl_Rtik_Subtype_Array_Ptr
                  | Ghdl_Rtik_Type_E8
                  | Ghdl_Rtik_Type_E32
-                 | Ghdl_Rtik_Type_B2 =>
+                 | Ghdl_Rtik_Type_B2
+                 | Ghdl_Rtik_Subtype_Scalar =>
                   Rti_To_Handle (Ch, Iterator.Ctxt, Res);
                   if Res.Kind /= VhpiUndefined then
                      Error := AvhpiErrorOk;
                      return;
                   else
-                     Internal_Error ("vhpi_handle");
+                     Internal_Error ("vhpi_scan_decls");
                   end if;
                when others =>
                   null;
@@ -533,6 +578,10 @@
             case Obj.Kind is
                when VhpiEnumTypeDeclK =>
                   Add (To_Ghdl_Rtin_Type_Enum_Acc (Obj.Atype).Name);
+               when VhpiSubtypeDeclK =>
+                  Add (To_Ghdl_Rtin_Subtype_Scalar_Acc (Obj.Atype).Name);
+               when VhpiArrayTypeDeclK =>
+                  Add (To_Ghdl_Rtin_Type_Array_Acc (Obj.Atype).Name);
                when VhpiPackInstK
                  | VhpiArchBodyK
                  | VhpiEntityDeclK
@@ -554,8 +603,6 @@
                  | VhpiPortDeclK
                  | VhpiGenericDeclK =>
                   Add (Obj.Obj.Name);
-               when VhpiSubtypeDeclK =>
-                  Add (To_Ghdl_Rtin_Subtype_Scalar_Acc (Obj.Atype).Name);
                when VhpiForGenerateK =>
                   declare
                      Blk : Ghdl_Rtin_Block_Acc;
@@ -605,7 +652,7 @@
                   declare
                      Comp : Ghdl_Rtin_Component_Acc;
                   begin
-                     Comp := To_Ghdl_Rtin_Component_Acc (Obj.Obj.Obj_Type);
+                     Comp := To_Ghdl_Rtin_Component_Acc (Obj.Inst.Instance);
                      if Comp.Common.Kind = Ghdl_Rtik_Component then
                         Add (Comp.Name);
                      end if;
@@ -748,12 +795,226 @@
                when others =>
                   return;
             end case;
+         when VhpiBaseType =>
+            declare
+               Atype : Ghdl_Rti_Access;
+            begin
+               case Ref.Kind is
+                  when VhpiSubtypeIndicK
+                    | VhpiSubtypeDeclK
+                    | VhpiArrayTypeDeclK =>
+                     Atype := Ref.Atype;
+                  when VhpiGenericDeclK =>
+                     Atype := Ref.Obj.Obj_Type;
+                  when VhpiIndexedNameK =>
+                     Atype := Ref.N_Type;
+                  when others =>
+                     return;
+               end case;
+               case Atype.Kind is
+                  when Ghdl_Rtik_Subtype_Array =>
+                     Rti_To_Handle
+                       (To_Ghdl_Rti_Access (To_Ghdl_Rtin_Subtype_Array_Acc
+                                            (Atype).Basetype),
+                        Ref.Ctxt, Res);
+                     if Res.Kind /= VhpiUndefined then
+                        Error := AvhpiErrorOk;
+                     end if;
+                  when Ghdl_Rtik_Subtype_Scalar =>
+                     Rti_To_Handle
+                       (To_Ghdl_Rtin_Subtype_Scalar_Acc (Atype).Basetype,
+                        Ref.Ctxt, Res);
+                     if Res.Kind /= VhpiUndefined then
+                        Error := AvhpiErrorOk;
+                     end if;
+                  when Ghdl_Rtik_Type_Array =>
+                     Res := Ref;
+                     Error := AvhpiErrorOk;
+                  when others =>
+                     return;
+               end case;
+            end;
+         when VhpiElemSubtype =>
+            declare
+               Base_Type : Ghdl_Rtin_Type_Array_Acc;
+            begin
+               case Ref.Atype.Kind is
+                  when Ghdl_Rtik_Subtype_Array =>
+                     Base_Type :=
+                       To_Ghdl_Rtin_Subtype_Array_Acc (Ref.Atype).Basetype;
+                  when Ghdl_Rtik_Type_Array =>
+                     Base_Type := To_Ghdl_Rtin_Type_Array_Acc (Ref.Atype);
+                  when others =>
+                     return;
+               end case;
+               Rti_To_Handle (Base_Type.Element, Ref.Ctxt, Res);
+               if Res.Kind /= VhpiUndefined then
+                  Error := AvhpiErrorOk;
+               end if;
+            end;
          when others =>
             Res := Null_Handle;
             Error := AvhpiErrorNotImplemented;
       end case;
    end Vhpi_Handle;
 
+   procedure Vhpi_Handle_By_Index (Rel : VhpiOneToManyT;
+                                   Ref : VhpiHandleT;
+                                   Index : Natural;
+                                   Res : out VhpiHandleT;
+                                   Error : out AvhpiErrorT)
+   is
+   begin
+      --  Default error.
+      Error := AvhpiErrorNotImplemented;
+
+      case Rel is
+         when VhpiConstraints =>
+            case Ref.Kind is
+               when VhpiSubtypeIndicK =>
+                  if Ref.Atype.Kind = Ghdl_Rtik_Subtype_Array then
+                     declare
+                        Arr_Subtype : Ghdl_Rtin_Subtype_Array_Acc :=
+                          To_Ghdl_Rtin_Subtype_Array_Acc (Ref.Atype);
+                        Basetype : Ghdl_Rtin_Type_Array_Acc :=
+                          Arr_Subtype.Basetype;
+                        Idx : Ghdl_Index_Type := Ghdl_Index_Type (Index);
+                        Bounds : Ghdl_Range_Array (0 .. Basetype.Nbr_Dim - 1);
+                        Range_Basetype : Ghdl_Rti_Access;
+                     begin
+                        if Idx not in 1 .. Basetype.Nbr_Dim then
+                           Res := Null_Handle;
+                           Error := AvhpiErrorBadIndex;
+                           return;
+                        end if;
+                        --  constraint type is basetype.indexes (idx - 1)
+                        Bound_To_Range
+                          (Loc_To_Addr (Arr_Subtype.Common.Depth,
+                                        Arr_Subtype.Bounds, Ref.Ctxt),
+                           Basetype, Bounds);
+                        Res := (Kind => VhpiIntRangeK,
+                                Ctxt => Ref.Ctxt,
+                                Rng_Type => Basetype.Indexes (Idx - 1),
+                                Rng_Addr => Bounds (Idx - 1));
+                        Range_Basetype := Get_Base_Type (Res.Rng_Type);
+                        case Range_Basetype.Kind is
+                           when Ghdl_Rtik_Type_I32 =>
+                              null;
+                           when Ghdl_Rtik_Type_E8
+                             | Ghdl_Rtik_Type_E32 =>
+                              Res := (Kind => VhpiEnumRangeK,
+                                      Ctxt => Ref.Ctxt,
+                                      Rng_Type => Res.Rng_Type,
+                                      Rng_Addr => Res.Rng_Addr);
+                           when others =>
+                              Internal_Error
+                                ("vhpi_handle_by_index/constraint");
+                        end case;
+                        Error := AvhpiErrorOk;
+                     end;
+                  end if;
+               when others =>
+                  return;
+            end case;
+         when VhpiIndexedNames =>
+            declare
+               Base_Type, El_Type : VhpiHandleT;
+            begin
+               Vhpi_Handle (VhpiBaseType, Ref, Base_Type, Error);
+               if Error /= AvhpiErrorOk then
+                  return;
+               end if;
+               if Vhpi_Get_Kind (Base_Type) /= VhpiArrayTypeDeclK then
+                  Error := AvhpiErrorBadRel;
+                  return;
+               end if;
+               Vhpi_Handle (VhpiElemSubtype, Base_Type, El_Type, Error);
+               if Error /= AvhpiErrorOk then
+                  return;
+               end if;
+               Res := (Kind => VhpiIndexedNameK,
+                       Ctxt => Ref.Ctxt,
+                       N_Addr => Avhpi_Get_Address (Ref),
+                       N_Type => El_Type.Atype,
+                       N_Idx => Ghdl_Index_Type (Index),
+                       N_Obj => Ref.Obj);
+               if Res.N_Addr = Null_Address then
+                  Error := AvhpiErrorBadRel;
+                  return;
+               end if;
+               Res.N_Addr := Add_Index
+                 (Res.Ctxt, Res.N_Addr, Res.N_Obj, Res.N_Type,
+                  Ghdl_Index_Type (Index));
+            end;
+         when others =>
+            Res := Null_Handle;
+            Error := AvhpiErrorNotImplemented;
+      end case;
+   end Vhpi_Handle_By_Index;
+
+   procedure Vhpi_Get (Property : VhpiIntPropertyT;
+                       Obj : VhpiHandleT;
+                       Res : out VhpiIntT;
+                       Error : out AvhpiErrorT)
+   is
+   begin
+      case Property is
+         when VhpiLeftBoundP =>
+            if Obj.Kind /= VhpiIntRangeK then
+               Error := AvhpiErrorBadRel;
+               return;
+            end if;
+            Error := AvhpiErrorOk;
+            case Get_Base_Type (Obj.Rng_Type).Kind is
+               when Ghdl_Rtik_Type_I32 =>
+                  Res := Obj.Rng_Addr.I32.Left;
+               when others =>
+                  Error := AvhpiErrorNotImplemented;
+            end case;
+            return;
+         when VhpiRightBoundP =>
+            if Obj.Kind /= VhpiIntRangeK then
+               Error := AvhpiErrorBadRel;
+               return;
+            end if;
+            Error := AvhpiErrorOk;
+            case Get_Base_Type (Obj.Rng_Type).Kind is
+               when Ghdl_Rtik_Type_I32 =>
+                  Res := Obj.Rng_Addr.I32.Right;
+               when others =>
+                  Error := AvhpiErrorNotImplemented;
+            end case;
+            return;
+         when others =>
+            Error := AvhpiErrorNotImplemented;
+      end case;
+   end Vhpi_Get;
+
+   procedure Vhpi_Get (Property : VhpiIntPropertyT;
+                       Obj : VhpiHandleT;
+                       Res : out Boolean;
+                       Error : out AvhpiErrorT)
+   is
+   begin
+      case Property is
+         when VhpiIsUpP =>
+            if Obj.Kind /= VhpiIntRangeK then
+               Error := AvhpiErrorBadRel;
+               return;
+            end if;
+            Error := AvhpiErrorOk;
+            case Get_Base_Type (Obj.Rng_Type).Kind is
+               when Ghdl_Rtik_Type_I32 =>
+                  Res := Obj.Rng_Addr.I32.Dir = Dir_To;
+               when others =>
+                  Error := AvhpiErrorNotImplemented;
+            end case;
+            return;
+         when others =>
+            Error := AvhpiErrorNotImplemented;
+      end case;
+   end Vhpi_Get;
+
    function Vhpi_Get_EntityClass (Obj : VhpiHandleT)
                                  return VhpiEntityClassT
    is
@@ -771,7 +1032,7 @@
       return Obj.Kind;
    end Vhpi_Get_Kind;
 
-   function Vhpi_Get_Mode (Obj : VhpiHandleT) return VhpiModeP is
+   function Vhpi_Get_Mode (Obj : VhpiHandleT) return VhpiModeT is
    begin
       case Obj.Kind is
          when VhpiPortDeclK =>
@@ -838,7 +1099,8 @@
       case Hdl1.Kind is
          when VhpiSubtypeIndicK
            | VhpiSubtypeDeclK
-           | VhpiArrayTypeDeclK =>
+           | VhpiArrayTypeDeclK
+           | VhpiPhysTypeDeclK =>
             return Hdl1.Atype = Hdl2.Atype;
          when others =>
             -- FIXME: todo
diff -urN ghdl-0.26/vhdl/grt/grt-avhpi.ads ghdl-0.26dev/vhdl/grt/grt-avhpi.ads
--- ghdl-0.26/vhdl/grt/grt-avhpi.ads	2005-09-22 23:52:31.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-avhpi.ads	2008-06-02 23:50:40.000000000 +0200
@@ -294,6 +294,80 @@
       VhpiLibraryDecls
      );
 
+   type VhpiIntPropertyT is
+     (
+      VhpiAccessP,
+      VhpiArgcP,
+      VhpiAttrKindP,
+      VhpiBaseIndexP,
+      VhpiBeginLineNoP,
+      VhpiEndLineNoP,
+      VhpiEntityClassP,
+      VhpiForeignKindP,
+      VhpiFrameLevelP,
+      VhpiGenerateIndexP,
+      VhpiIntValP,
+      VhpiIsAnonymousP,
+      VhpiIsBasicP,
+      VhpiIsCompositeP,
+      VhpiIsDefaultP,
+      VhpiIsDeferredP,
+      VhpiIsDiscreteP,
+      VhpiIsForcedP,
+      VhpiIsForeignP,
+      VhpiIsGuardedP,
+      VhpiIsImplicitDeclP,
+      VhpiIsInvalidP_DEPRECATED,
+      VhpiIsLocalP,
+      VhpiIsNamedP,
+      VhpiIsNullP,
+      VhpiIsOpenP,
+      VhpiIsPLIP,
+      VhpiIsPassiveP,
+      VhpiIsPostponedP,
+      VhpiIsProtectedTypeP,
+      VhpiIsPureP,
+      VhpiIsResolvedP,
+      VhpiIsScalarP,
+      VhpiIsSeqStmtP,
+      VhpiIsSharedP,
+      VhpiIsTransportP,
+      VhpiIsUnaffectedP,
+      VhpiIsUnconstrainedP,
+      VhpiIsUninstantiatedP,
+      VhpiIsUpP,
+      VhpiIsVitalP,
+      VhpiIteratorTypeP,
+      VhpiKindP,
+      VhpiLeftBoundP,
+      VhpiLevelP_DEPRECATED,
+      VhpiLineNoP,
+      VhpiLineOffsetP,
+      VhpiLoopIndexP,
+      VhpiModeP,
+      VhpiNumDimensionsP,
+      VhpiNumFieldsP_DEPRECATED,
+      VhpiNumGensP,
+      VhpiNumLiteralsP,
+      VhpiNumMembersP,
+      VhpiNumParamsP,
+      VhpiNumPortsP,
+      VhpiOpenModeP,
+      VhpiPhaseP,
+      VhpiPositionP,
+      VhpiPredefAttrP,
+      VhpiReasonP,
+      VhpiRightBoundP,
+      VhpiSigKindP,
+      VhpiSizeP,
+      VhpiStartLineNoP,
+      VhpiStateP,
+      VhpiStaticnessP,
+      VhpiVHDLversionP,
+      VhpiIdP,
+      VhpiCapabilitiesP
+     );
+
    --  String properties.
    type VhpiStrPropertyT is
      (
@@ -323,7 +397,8 @@
       AvhpiErrorBadRel,
       AvhpiErrorHandle,
       AvhpiErrorNotImplemented,
-      AvhpiErrorIteratorEnd
+      AvhpiErrorIteratorEnd,
+      AvhpiErrorBadIndex
      );
 
    type VhpiHandleT is private;
@@ -342,6 +417,12 @@
                           Res : out VhpiHandleT;
                           Error : out AvhpiErrorT);
 
+   procedure Vhpi_Handle_By_Index (Rel : VhpiOneToManyT;
+                                   Ref : VhpiHandleT;
+                                   Index : Natural;
+                                   Res : out VhpiHandleT;
+                                   Error : out AvhpiErrorT);
+
    procedure Vhpi_Iterator (Rel : VhpiOneToManyT;
                             Ref : VhpiHandleT;
                             Res : out VhpiHandleT;
@@ -355,6 +436,17 @@
                            Res : out String;
                            Len : out Natural);
 
+   subtype VhpiIntT is Ghdl_I32;
+
+   procedure Vhpi_Get (Property : VhpiIntPropertyT;
+                       Obj : VhpiHandleT;
+                       Res : out VhpiIntT;
+                       Error : out AvhpiErrorT);
+   procedure Vhpi_Get (Property : VhpiIntPropertyT;
+                       Obj : VhpiHandleT;
+                       Res : out Boolean;
+                       Error : out AvhpiErrorT);
+
    --  Almost the same as Vhpi_Get_Str (VhpiName, OBJ), but there is not
    --  indexes for generate stmt.
    function Avhpi_Get_Base_Name (Obj : VhpiHandleT) return Ghdl_C_String;
@@ -392,7 +484,7 @@
    function Vhpi_Get_EntityClass (Obj : VhpiHandleT)
                                  return VhpiEntityClassT;
 
-   type VhpiModeP is
+   type VhpiModeT is
      (
       VhpiErrorMode,
       VhpiInMode,
@@ -401,7 +493,7 @@
       VhpiBufferMode,
       VhpiLinkageMode
      );
-   function Vhpi_Get_Mode (Obj : VhpiHandleT) return VhpiModeP;
+   function Vhpi_Get_Mode (Obj : VhpiHandleT) return VhpiModeT;
 
    function Avhpi_Get_Rti (Obj : VhpiHandleT) return Ghdl_Rti_Access;
 
@@ -438,10 +530,17 @@
          when VhpiSubtypeIndicK
            | VhpiSubtypeDeclK
            | VhpiArrayTypeDeclK
-           | VhpiEnumTypeDeclK =>
+           | VhpiEnumTypeDeclK
+           | VhpiPhysTypeDeclK =>
             Atype : Ghdl_Rti_Access;
          when VhpiCompInstStmtK =>
             Inst : Ghdl_Rtin_Instance_Acc;
+         when VhpiIntRangeK
+           | VhpiEnumRangeK
+           | VhpiFloatRangeK
+           | VhpiPhysRangeK =>
+            Rng_Type : Ghdl_Rti_Access;
+            Rng_Addr : Ghdl_Range_Ptr;
          when others =>
             null;
       end case;
diff -urN ghdl-0.26/vhdl/grt/grt-errors.adb ghdl-0.26dev/vhdl/grt/grt-errors.adb
--- ghdl-0.26/vhdl/grt/grt-errors.adb	2005-09-23 00:26:39.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-errors.adb	2008-06-02 23:50:40.000000000 +0200
@@ -125,6 +125,16 @@
       Newline_Err;
    end Report_E;
 
+   procedure Report_E (Str : Std_String_Ptr)
+   is
+      subtype Ada_Str is String (1 .. Natural (Str.Bounds.Dim_1.Length));
+   begin
+      if Ada_Str'Length > 0 then
+         Put_Err (Ada_Str (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+      end if;
+      Newline_Err;
+   end Report_E;
+
    procedure Error_H is
    begin
       Put_Err (Progname);
@@ -193,6 +203,13 @@
       Fatal_Error;
    end Error_E;
 
+   procedure Error_E_Std (Str : Std_String_Uncons)
+   is
+      subtype Str_Subtype is String (1 .. Str'Length);
+   begin
+      Error_E (Str_Subtype (Str));
+   end Error_E_Std;
+
    procedure Error (Str : String) is
    begin
       Error_H;
diff -urN ghdl-0.26/vhdl/grt/grt-errors.ads ghdl-0.26dev/vhdl/grt/grt-errors.ads
--- ghdl-0.26/vhdl/grt/grt-errors.ads	2005-09-23 00:26:29.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-errors.ads	2008-06-02 23:50:40.000000000 +0200
@@ -27,6 +27,7 @@
    procedure Error_C (Str : Ghdl_C_String);
    --procedure Error_C (Inst : Ghdl_Instance_Name_Acc);
    procedure Error_E (Str : String);
+   procedure Error_E_Std (Str : Std_String_Uncons);
    pragma No_Return (Error_E);
 
    --  Multi-call report procedure.  Do not exit at end.
@@ -36,6 +37,7 @@
    procedure Report_C (N : Integer);
    procedure Report_Now_C;
    procedure Report_E (Str : String);
+   procedure Report_E (Str : Std_String_Ptr);
 
    --  Complete error message.
    procedure Error (Str : String);
diff -urN ghdl-0.26/vhdl/grt/grt-files.adb ghdl-0.26dev/vhdl/grt/grt-files.adb
--- ghdl-0.26/vhdl/grt/grt-files.adb	2006-05-29 21:28:44.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-files.adb	2008-06-02 23:50:40.000000000 +0200
@@ -1,5 +1,5 @@
 --  GHDL Run Time (GRT) -  VHDL files subprograms.
---  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Tristan Gingold
 --
 --  GHDL is free software; you can redistribute it and/or modify it under
 --  the terms of the GNU General Public License as published by the Free
@@ -247,7 +247,7 @@
 
       if Res /= Open_Ok then
          Error_C ("open: cannot open text file ");
-         Error_E (String (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+         Error_E_Std (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1));
       end if;
    end Ghdl_Text_File_Open;
 
@@ -262,7 +262,7 @@
 
       if Res /= Open_Ok then
          Error_C ("open: cannot open file ");
-         Error_E (String (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+         Error_E_Std (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1));
       end if;
    end Ghdl_File_Open;
 
diff -urN ghdl-0.26/vhdl/grt/grt-lib.adb ghdl-0.26dev/vhdl/grt/grt-lib.adb
--- ghdl-0.26/vhdl/grt/grt-lib.adb	2006-08-11 05:09:50.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-lib.adb	2008-06-02 23:50:40.000000000 +0200
@@ -63,7 +63,7 @@
             Report_C ("???");
       end case;
       Report_C ("): ");
-      Report_E (String (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+      Report_E (Str);
       if Level >= Grt.Options.Severity_Level then
          Error_C (Msg);
          Error_E (" failed");
diff -urN ghdl-0.26/vhdl/grt/grt-processes.adb ghdl-0.26dev/vhdl/grt/grt-processes.adb
--- ghdl-0.26/vhdl/grt/grt-processes.adb	2007-03-28 01:11:42.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-processes.adb	2008-06-02 23:50:40.000000000 +0200
@@ -111,6 +111,9 @@
    begin
       if State /= State_Sensitized then
          Stack := Stack_Create (Proc, This);
+         if Stack = Null_Stack then
+            Internal_Error ("cannot allocate stack: memory exhausted");
+         end if;
       else
          Stack := Null_Stack;
       end if;
diff -urN ghdl-0.26/vhdl/grt/grt-rtis_addr.ads ghdl-0.26dev/vhdl/grt/grt-rtis_addr.ads
--- ghdl-0.26/vhdl/grt/grt-rtis_addr.ads	2005-09-23 00:30:36.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-rtis_addr.ads	2008-06-02 23:50:40.000000000 +0200
@@ -43,6 +43,10 @@
    function To_Addr_Acc is new Ada.Unchecked_Conversion
      (Source => Address, Target => Addr_Acc);
 
+   type Ghdl_Index_Acc is access Ghdl_Index_Type;
+   function To_Ghdl_Index_Acc is new Ada.Unchecked_Conversion
+     (Source => Address, Target => Ghdl_Index_Acc);
+
    --  Get the parent context of CTXT.
    --  The parent of an architecture is its entity.
    function Get_Parent_Context (Ctxt : Rti_Context) return Rti_Context;
diff -urN ghdl-0.26/vhdl/grt/grt-sdf.adb ghdl-0.26dev/vhdl/grt/grt-sdf.adb
--- ghdl-0.26/vhdl/grt/grt-sdf.adb	2005-10-08 14:06:15.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-sdf.adb	2008-06-02 23:50:40.000000000 +0200
@@ -267,7 +267,7 @@
       Pos := 1;
    end Refill_Buf;
 
-   function Get_Token return Sdf_Token_Type
+   procedure Skip_Spaces
    is
       use Ada.Characters.Latin_1;
    begin
@@ -277,21 +277,20 @@
       end loop;
 
       loop
-         --  Be sure there is at least 4 characters.
-         if Pos + 4 >= Buf_Len then
+         --  Be sure there is at least 1 character.
+         if Pos + 1 >= Buf_Len then
             Refill_Buf;
          end if;
 
          case Buf (Pos) is
             when EOT =>
                if Pos /= Buf_Len then
-                  Error_Bad_Character;
-                  return Tok_Error;
+                  return;
                end if;
                Pos := 1;
                Read_Sdf;
                if Buf_Len = 1 then
-                  return Tok_Eof;
+                  return;
                end if;
             when LF =>
                Pos := Pos + 1;
@@ -307,38 +306,79 @@
                end if;
                Line_Start := Pos;
                Sdf_Line := Sdf_Line + 1;
-            when '"' => -- "
-               Scan_Qstring;
-               return Tok_Qstring;
             when ' '
               | HT =>
                Pos := Pos + 1;
             when '/' =>
-               Pos := Pos + 1;
-               return Tok_Div;
-            when '.' =>
-               Pos := Pos + 1;
-               return Tok_Dot;
-            when ':' =>
-               Pos := Pos + 1;
-               return Tok_Cln;
-            when '(' =>
-               Pos := Pos + 1;
-               return Tok_Oparen;
-            when ')' =>
-               Pos := Pos + 1;
-               return Tok_Cparen;
-            when 'a' .. 'z'
-              | 'A' .. 'Z' =>
-               Scan_Identifier;
-               return Tok_Identifier;
-            when '0' .. '9' =>
-               return Scan_Number;
+               if Buf (Pos + 1) = '/' then
+                  Pos := Pos + 2;
+                  --  Skip line comment.
+                  loop
+                     exit when Buf (Pos) = CR;
+                     exit when Buf (Pos) = LF;
+                     exit when Buf (Pos) = EOT;
+                     Pos := Pos + 1;
+                     if Pos >= Buf_Len then
+                        Refill_Buf;
+                     end if;
+                  end loop;
+               else
+                  return;
+               end if;
             when others =>
-               Error_Bad_Character;
-               return Tok_Error;
+               return;
          end case;
       end loop;
+   end Skip_Spaces;
+
+   function Get_Token return Sdf_Token_Type
+   is
+      use Ada.Characters.Latin_1;
+   begin
+      Skip_Spaces;
+
+      --  Be sure there is at least 4 characters.
+      if Pos + 4 >= Buf_Len then
+         Refill_Buf;
+      end if;
+
+      case Buf (Pos) is
+         when EOT =>
+            if Buf_Len = 1 then
+               return Tok_Eof;
+            else
+               Error_Bad_Character;
+               return Tok_Error;
+            end if;
+         when '"' => -- "
+            Scan_Qstring;
+            return Tok_Qstring;
+         when '/' =>
+            --  Skip_Spaces has already handled line comments.
+            Pos := Pos + 1;
+            return Tok_Div;
+         when '.' =>
+            Pos := Pos + 1;
+            return Tok_Dot;
+         when ':' =>
+            Pos := Pos + 1;
+            return Tok_Cln;
+         when '(' =>
+            Pos := Pos + 1;
+            return Tok_Oparen;
+         when ')' =>
+            Pos := Pos + 1;
+            return Tok_Cparen;
+         when 'a' .. 'z'
+           | 'A' .. 'Z' =>
+            Scan_Identifier;
+            return Tok_Identifier;
+         when '0' .. '9' =>
+            return Scan_Number;
+         when others =>
+            Error_Bad_Character;
+            return Tok_Error;
+      end case;
    end Get_Token;
 
    function Is_White_Space (C : Character) return Boolean
@@ -360,90 +400,57 @@
    is
       use Ada.Characters.Latin_1;
    begin
-      loop
-         --  Be sure there is at least 4 characters.
-         if Pos + 4 >= Buf_Len then
-            Refill_Buf;
-         end if;
+      Skip_Spaces;
 
-         case Buf (Pos) is
-            when EOT =>
-               if Pos /= Buf_Len then
-                  exit;
-               end if;
-               Pos := 1;
-               Read_Sdf;
-               if Buf_Len = 1 then
-                  exit;
-               end if;
-            when LF =>
-               Pos := Pos + 1;
-               if Buf (Pos) = CR then
-                  Pos := Pos + 1;
-               end if;
-               Line_Start := Pos;
-               Sdf_Line := Sdf_Line + 1;
-            when CR =>
-               Pos := Pos + 1;
-               if Buf (Pos) = LF then
-                  Pos := Pos + 1;
+      --  Be sure there is at least 4 characters.
+      if Pos + 4 >= Buf_Len then
+         Refill_Buf;
+      end if;
+
+      case Buf (Pos) is
+         when '0' =>
+            if Is_White_Space (Buf (Pos + 2)) then
+               if Buf (Pos + 1) = 'z' then
+                  Pos := Pos + 2;
+                  return Edge_0z;
+               elsif Buf (Pos + 1) = '1' then
+                  Pos := Pos + 2;
+                  return Edge_01;
                end if;
-               Line_Start := Pos;
-               Sdf_Line := Sdf_Line + 1;
-            when ' '
-              | HT =>
-               Pos := Pos + 1;
-            when '0' =>
-               if Is_White_Space (Buf (Pos + 2)) then
-                  if Buf (Pos + 1) = 'z' then
-                     Pos := Pos + 2;
-                     return Edge_0z;
-                  elsif Buf (Pos + 1) = '1' then
-                     Pos := Pos + 2;
-                     return Edge_01;
-                  end if;
-               end if;
-               exit;
-            when '1' =>
-               if Is_White_Space (Buf (Pos + 2)) then
-                  if Buf (Pos + 1) = 'z' then
-                     Pos := Pos + 2;
-                     return Edge_1z;
-                  elsif Buf (Pos + 1) = '0' then
-                     Pos := Pos + 2;
-                     return Edge_10;
-                  end if;
-               end if;
-               exit;
-            when 'z' =>
-               if Is_White_Space (Buf (Pos + 2)) then
-                  if Buf (Pos + 1) = '0' then
-                     Pos := Pos + 2;
-                     return Edge_Z0;
-                  elsif Buf (Pos + 1) = '1' then
-                     Pos := Pos + 2;
-                     return Edge_Z1;
-                  end if;
-               end if;
-               exit;
-            when 'p' =>
-               Scan_Identifier;
-               if Is_Ident ("posedge") then
-                  return Edge_Posedge;
-               else
-                  exit;
+            end if;
+         when '1' =>
+            if Is_White_Space (Buf (Pos + 2)) then
+               if Buf (Pos + 1) = 'z' then
+                  Pos := Pos + 2;
+                  return Edge_1z;
+               elsif Buf (Pos + 1) = '0' then
+                  Pos := Pos + 2;
+                  return Edge_10;
                end if;
-            when 'n' =>
-               Scan_Identifier;
-               if Is_Ident ("negedge") then
-                  return Edge_Negedge;
-               else
-                  exit;
+            end if;
+         when 'z' =>
+            if Is_White_Space (Buf (Pos + 2)) then
+               if Buf (Pos + 1) = '0' then
+                  Pos := Pos + 2;
+                  return Edge_Z0;
+               elsif Buf (Pos + 1) = '1' then
+                  Pos := Pos + 2;
+                  return Edge_Z1;
                end if;
-            when others =>
-               exit;
-         end case;
-      end loop;
+            end if;
+         when 'p' =>
+            Scan_Identifier;
+            if Is_Ident ("posedge") then
+               return Edge_Posedge;
+            end if;
+         when 'n' =>
+            Scan_Identifier;
+            if Is_Ident ("negedge") then
+               return Edge_Negedge;
+            end if;
+         when others =>
+            null;
+      end case;
       Error_Sdf ("edge_identifier expected");
       return Edge_Error;
    end Get_Edge_Token;
@@ -510,6 +517,8 @@
    begin
       Sdf_Context.Kind := Kind;
       Sdf_Context.Port_Num := 0;
+      Sdf_Context.Ports (1).L := Invalid_Dnumber;
+      Sdf_Context.Ports (2).L := Invalid_Dnumber;
       Sdf_Context.Ports (1).Edge := Edge_None;
       Sdf_Context.Ports (2).Edge := Edge_None;
    end Start_Generic_Name;
@@ -651,6 +660,35 @@
          Port_Spec.Name (Len) := To_Lower (Buf (I));
       end loop;
       Port_Spec.Name_Len := Len;
+
+      --  Parse   [ DNUMBER ]
+      --        | [ DNUMBER : DNUMBER ]
+      Skip_Spaces;
+      if Buf (Pos) = '[' then
+         Port_Spec.R := Invalid_Dnumber;
+         Pos := Pos + 1;
+         if Get_Token /= Tok_Dnumber then
+            Error_Sdf (Tok);
+         else
+            Port_Spec.L := Ghdl_I32 (Scan_Int);
+         end if;
+         Skip_Spaces;
+         if Buf (Pos) = ':' then
+            Pos := Pos + 1;
+            if Get_Token /= Tok_Dnumber then
+               Error_Sdf (Tok);
+            else
+               Port_Spec.R := Ghdl_I32 (Scan_Int);
+            end if;
+            Skip_Spaces;
+         end if;
+         if Buf (Pos) /= ']' then
+            Error_Sdf ("']' expected");
+         else
+            Pos := Pos + 1;
+         end if;
+      end if;
+
       return True;
    end Parse_Port_Path1;
 
@@ -1101,20 +1139,24 @@
             exit when not Is_Ident ("INSTANCE");
             Tok := Get_Token;
             if Tok /= Tok_Cparen then
-               if Tok /= Tok_Identifier then
-                  Error_Sdf ("instance identifier expected");
-                  return False;
-               end if;
-               for I in Ident_Start .. Ident_End loop
-                  Buf (I) := To_Lower (Buf (I));
+               loop
+                  if Tok /= Tok_Identifier then
+                     Error_Sdf ("instance identifier expected");
+                     return False;
+                  end if;
+                  for I in Ident_Start .. Ident_End loop
+                     Buf (I) := To_Lower (Buf (I));
+                  end loop;
+                  Vital_Annotate.Sdf_Instance
+                    (Sdf_Context.all, Buf (Ident_Start .. Ident_End), Ok);
+                  if not Ok then
+                     Error_Sdf ("cannot find instance");
+                     return False;
+                  end if;
+                  Tok := Get_Token;
+                  exit when Tok /= Tok_Dot;
+                  Tok := Get_Token;
                end loop;
-               Vital_Annotate.Sdf_Instance
-                 (Sdf_Context.all, Buf (Ident_Start .. Ident_End), Ok);
-               if not Ok then
-                  Error_Sdf ("cannot find instance");
-                  return False;
-               end if;
-               Tok := Get_Token;
             end if;
             if Tok /= Tok_Cparen
               or else Get_Token /= Tok_Oparen
diff -urN ghdl-0.26/vhdl/grt/grt-sdf.ads ghdl-0.26dev/vhdl/grt/grt-sdf.ads
--- ghdl-0.26/vhdl/grt/grt-sdf.ads	2005-09-23 00:23:30.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-sdf.ads	2008-06-02 23:50:40.000000000 +0200
@@ -68,11 +68,22 @@
    Read_Size : constant Natural := 4096;
    Buf_Size : constant Natural := Read_Size + 1024 + 1;
 
+   Invalid_Dnumber : constant Ghdl_I32 := -1;
+
    type Port_Spec_Type is record
-      Name : String (1 .. 1024);
+      --  Port identifier.
+      Name : String (1 .. 128);
       Name_Len : Natural;
+
+      --  Left and Right range.
+      --  If L = R = Invalid_Dnumber, this is a simple scalar port.
+      --  If R = Invalid_Dnumber, this is a scalar port (from a vector)
+      --  Otherwise, this is a bus port.
+      L, R : Ghdl_I32;
+
    -- Cond : String (1 .. 1024);
    -- Cond_Len : Natural;
+
       Edge : Edge_Type;
    end record;
 
diff -urN ghdl-0.26/vhdl/grt/grt-signals.adb ghdl-0.26dev/vhdl/grt/grt-signals.adb
--- ghdl-0.26/vhdl/grt/grt-signals.adb	2006-09-27 03:57:48.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-signals.adb	2008-06-02 23:50:40.000000000 +0200
@@ -2709,10 +2709,15 @@
          if Last.Time > Trans.Time then
             Internal_Error ("delayed time");
          elsif Last.Time = Trans.Time then
-            if Prev = Last then
-               Internal_Error ("delayed");
+            if Prev /= Last then
+               Free (Last);
+            else
+               --  No transaction.
+               if Last.Time /= 0 then
+                  --  This can happen only at time = 0.
+                  Internal_Error ("delayed");
+               end if;
             end if;
-            Free (Last);
          else
             Prev := Last;
          end if;
diff -urN ghdl-0.26/vhdl/grt/grt-types.ads ghdl-0.26dev/vhdl/grt/grt-types.ads
--- ghdl-0.26/vhdl/grt/grt-types.ads	2006-09-29 05:28:46.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-types.ads	2008-06-02 23:50:40.000000000 +0200
@@ -58,7 +58,8 @@
    end record;
 
    subtype Std_Character is Character;
-   type Std_String_Base is array (Ghdl_Index_Type) of Std_Character;
+   type Std_String_Uncons is array (Ghdl_Index_Type range <>) of Std_Character;
+   subtype Std_String_Base is Std_String_Uncons (Ghdl_Index_Type);
    type Std_String_Basep is access Std_String_Base;
 
    type Std_String_Bound is record
diff -urN ghdl-0.26/vhdl/grt/grt-vital_annotate.adb ghdl-0.26dev/vhdl/grt/grt-vital_annotate.adb
--- ghdl-0.26/vhdl/grt/grt-vital_annotate.adb	2005-09-23 00:19:10.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-vital_annotate.adb	2008-06-02 23:50:40.000000000 +0200
@@ -78,27 +78,66 @@
 --       New_Line;
    end Find_Instance;
 
-   procedure Find_Generic
-     (Name : String; Res : out VhpiHandleT; Ok : out Boolean)
+   procedure Find_Generic (Gen_Name : String;
+                           Gen_Handle : out VhpiHandleT;
+                           Port1_Name : String;
+                           Port1_Handle : out VhpiHandleT;
+                           Port2_Name : String;
+                           Port2_Handle : out VhpiHandleT)
    is
       Error : AvhpiErrorT;
       It : VhpiHandleT;
+      Decl : VhpiHandleT;
    begin
-      Ok := False;
+      Gen_Handle := Null_Handle;
+      Port1_Handle := Null_Handle;
+      Port2_Handle := Null_Handle;
+
       Vhpi_Iterator (VhpiDecls, Sdf_Inst, It, Error);
       if Error /= AvhpiErrorOk then
          return;
       end if;
+
+      --  Look for the generic.
+      loop
+         Vhpi_Scan (It, Decl, Error);
+         if Error /= AvhpiErrorOk then
+            return;
+         end if;
+         exit when Vhpi_Get_Kind (Decl) /= VhpiGenericDeclK;
+         if Name_Compare (Decl, Gen_Name) then
+            Gen_Handle := Decl;
+            exit;
+         end if;
+      end loop;
+
+      --  Skip generics.
+      while Vhpi_Get_Kind (Decl) = VhpiGenericDeclK loop
+         Vhpi_Scan (It, Decl, Error);
+         if Error /= AvhpiErrorOk then
+            return;
+         end if;
+      end loop;
+
+      --  Look for ports.
       loop
-         Vhpi_Scan (It, Res, Error);
-         exit when Error /= AvhpiErrorOk;
-         exit when Vhpi_Get_Kind (Res) /= VhpiGenericDeclK;
-         if Name_Compare (Res, Name) then
-            Ok := True;
+         exit when Vhpi_Get_Kind (Decl) /= VhpiPortDeclK;
+         if Name_Compare (Decl, Port1_Name) then
+            Port1_Handle := Decl;
+            exit when Port2_Name'Length = 0;
+         end if;
+         if Port2_Name'Length > 0
+           and then Name_Compare (Decl, Port2_Name)
+         then
+            Port2_Handle := Decl;
+            exit when Vhpi_Get_Kind (Port1_Handle) /= VhpiUndefined;
+         end if;
+         Vhpi_Scan (It, Decl, Error);
+         if Error /= AvhpiErrorOk then
             return;
          end if;
       end loop;
-      return;
+
    end Find_Generic;
 
    procedure Sdf_Header (Context : in out Sdf_Context_Type)
@@ -191,6 +230,9 @@
    end Sdf_Instance_End;
 
    VitalDelayType01 : VhpiHandleT;
+   VitalDelayArrayType01 : VhpiHandleT;
+   VitalDelayType : VhpiHandleT;
+   VitalDelayArrayType : VhpiHandleT;
 
    type Map_Type is array (1 .. 12) of Natural;
    Map_1 : constant Map_Type := (1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0);
@@ -233,12 +275,88 @@
       return True;
    end Write_Td_Delay_Generic;
 
+   function Write_Td_Delay_Generic (Context : Sdf_Context_Type;
+                                    Gen : VhpiHandleT)
+                                   return Boolean
+   is
+      Gen_Basetype : VhpiHandleT;
+      Error : AvhpiErrorT;
+   begin
+      Vhpi_Handle (VhpiBaseType, Gen, Gen_Basetype, Error);
+      if Error /= AvhpiErrorOk then
+         Internal_Error ("write_td_delay_generic: vhpiBaseType");
+         return False;
+      end if;
+      if Vhpi_Compare_Handles (Gen_Basetype, VitalDelayType01) then
+         case Context.Timing_Nbr is
+            when 1 =>
+               return Write_Td_Delay_Generic (Context, Gen, 2, Map_1);
+            when 2 =>
+               return Write_Td_Delay_Generic (Context, Gen, 2, Map_2);
+            when others =>
+               Errors.Error
+                 ("timing generic type mismatch SDF timing specification");
+         end case;
+      elsif Vhpi_Compare_Handles (Gen_Basetype, VitalDelayType) then
+         if Vhpi_Put_Value (Gen, Context.Timing (1) * 1000) /= AvhpiErrorOk
+         then
+            Internal_Error ("vhpi_put_value (vitaldelaytype)");
+         else
+            return True;
+         end if;
+      else
+         Internal_Error ("write_td_delay_generic: unhandled generic type");
+      end if;
+   end Write_Td_Delay_Generic;
+
+   procedure Generic_Get_Bounds (Port : VhpiHandleT;
+                                 Left : out Ghdl_I32;
+                                 Len : out Ghdl_Index_Type;
+                                 Up : out Boolean)
+   is
+      Port_Type, Port_Range : VhpiHandleT;
+      Error : AvhpiErrorT;
+      Right : VhpiIntT;
+   begin
+      Vhpi_Handle (VhpiSubtype, Port, Port_Type, Error);
+      if Error /= AvhpiErrorOk then
+         Internal_Error ("vhpiSubtype - port");
+         return;
+      end if;
+      Vhpi_Handle_By_Index (VhpiConstraints, Port_Type, 1, Port_Range, Error);
+      if Error /= AvhpiErrorOk then
+         Internal_Error ("vhpiIndexConstraints - port");
+         return;
+      end if;
+      Vhpi_Get (VhpiLeftBoundP, Port_Range, Left, Error);
+      if Error /= AvhpiErrorOk then
+         Internal_Error ("vhpiLeftBoundP - port");
+         return;
+      end if;
+      Vhpi_Get (VhpiRightBoundP, Port_Range, Right, Error);
+      if Error /= AvhpiErrorOk then
+         Internal_Error ("vhpiRightBoundP - port");
+         return;
+      end if;
+      Vhpi_Get (VhpiIsUpP, Port_Range, Up, Error);
+      if Error /= AvhpiErrorOk then
+         Internal_Error ("vhpiIsUpP - port");
+         return;
+      end if;
+      if Up then
+         Len := Ghdl_Index_Type (Right - Left) + 1;
+      else
+         Len := Ghdl_Index_Type (Left - Right) + 1;
+      end if;
+   end Generic_Get_Bounds;
+
    procedure Sdf_Generic (Context : in out Sdf_Context_Type;
                           Name : String;
                           Ok : out Boolean)
    is
       Gen : VhpiHandleT;
-      Gen_Type : VhpiHandleT;
+      Gen_Basetype : VhpiHandleT;
+      Port1, Port2 : VhpiHandleT;
       Error : AvhpiErrorT;
    begin
       if Flag_Dump then
@@ -263,36 +381,75 @@
          return;
       end if;
 
-      Find_Generic (Name, Gen, Ok);
-      if not Ok then
-         return;
-      end if;
-
       Ok := False;
 
-      --  Extract subtype.
-      Vhpi_Handle (VhpiSubtype, Gen, Gen_Type, Error);
-      if Error /= AvhpiErrorOk then
-         Internal_Error ("vhpiSubtype");
+      if Context.Port_Num = 1 then
+         Context.Ports (2).Name_Len := 0;
+      end if;
+      Find_Generic
+        (Name, Gen,
+         Context.Ports (1).Name (1 .. Context.Ports (1).Name_Len), Port1,
+         Context.Ports (2).Name (1 .. Context.Ports (2).Name_Len), Port2);
+      if Vhpi_Get_Kind (Gen) = VhpiUndefined
+        or else Vhpi_Get_Kind (Port1) = VhpiUndefined
+        or else (Context.Port_Num = 2
+                 and then Vhpi_Get_Kind (Port2) = VhpiUndefined)
+      then
          return;
       end if;
-      Vhpi_Handle (VhpiTypeMark, Gen_Type, Gen_Type, Error);
+
+      --  Extract subtype.
+      Vhpi_Handle (VhpiBaseType, Gen, Gen_Basetype, Error);
       if Error /= AvhpiErrorOk then
-         Internal_Error ("vhpiTypeMark");
+         Internal_Error ("vhpiBaseType");
          return;
       end if;
-      if Vhpi_Compare_Handles (Gen_Type, VitalDelayType01) then
-         case Context.Timing_Nbr is
-            when 1 =>
-               Ok := Write_Td_Delay_Generic (Context, Gen, 2, Map_1);
-            when 2 =>
-               Ok := Write_Td_Delay_Generic (Context, Gen, 2, Map_2);
-            when others =>
-               Errors.Error
-                 ("timing generic type mismatch SDF timing specification");
-         end case;
+      if Vhpi_Compare_Handles (Gen_Basetype, VitalDelayType01) then
+         Ok := Write_Td_Delay_Generic (Context, Gen);
+      elsif Vhpi_Compare_Handles (Gen_Basetype, VitalDelayArrayType01)
+        or else Vhpi_Compare_Handles (Gen_Basetype, VitalDelayArrayType)
+      then
+         declare
+            Left_Gen, Left1, Left2 : Ghdl_I32;
+            Len_Gen, Len1, Len2 : Ghdl_Index_Type;
+            Up_Gen, Up1, Up2 : Boolean;
+            Pos : Ghdl_Index_Type;
+            Gen_El : VhpiHandleT;
+         begin
+            Generic_Get_Bounds (Gen, Left_Gen, Len_Gen, Up_Gen);
+            if Context.Port_Num >= 1
+              and then Context.Ports (1).L /= Invalid_Dnumber
+            then
+               Generic_Get_Bounds (Port1, Left1, Len1, Up1);
+               if Up1 then
+                  Pos := Ghdl_Index_Type (Context.Ports (1).L - Left1);
+               else
+                  Pos := Ghdl_Index_Type (Left1 - Context.Ports (1).L);
+               end if;
+            else
+               Pos := 0;
+            end if;
+            if Context.Port_Num >= 2
+              and then Context.Ports (2).L /= Invalid_Dnumber
+            then
+               Generic_Get_Bounds (Port2, Left2, Len2, Up2);
+               Pos := Pos * Len2;
+               if Up1 then
+                  Pos := Pos + Ghdl_Index_Type (Context.Ports (2).L - Left2);
+               else
+                  Pos := Pos + Ghdl_Index_Type (Left1 - Context.Ports (2).L);
+               end if;
+            end if;
+            Vhpi_Handle_By_Index
+              (VhpiIndexedNames, Gen, Integer (Pos), Gen_El, Error);
+            if Error /= AvhpiErrorOk then
+               Internal_Error ("vhpiIndexedNames - gen_el");
+               return;
+            end if;
+            Ok := Write_Td_Delay_Generic (Context, Gen_El);
+         end;
       else
-         Errors.Error ("bad generic type");
+         Errors.Error ("vital: unhandled generic type");
       end if;
    end Sdf_Generic;
 
@@ -357,6 +514,7 @@
       It : VhpiHandleT;
       Pkg : VhpiHandleT;
       Decl : VhpiHandleT;
+      Basetype : VhpiHandleT;
       Status : AvhpiErrorT;
    begin
       Get_Package_Inst (It);
@@ -378,12 +536,33 @@
       loop
          Vhpi_Scan (It, Decl, Status);
          exit when Status /= AvhpiErrorOk;
-         if Name_Compare (Decl, "vitaldelaytype01") then
-            VitalDelayType01 := Decl;
+         if Vhpi_Get_Kind (Decl) = VhpiSubtypeDeclK
+           or else Vhpi_Get_Kind (Decl) = VhpiArrayTypeDeclK
+         then
+            Vhpi_Handle (VhpiBaseType, Decl, Basetype, Status);
+            if Status = AvhpiErrorOk then
+               if Name_Compare (Decl, "vitaldelaytype01") then
+                  VitalDelayType01 := Basetype;
+               elsif Name_Compare (Decl, "vitaldelayarraytype01") then
+                  VitalDelayArrayType01 := Basetype;
+               elsif Name_Compare (Decl, "vitaldelaytype") then
+                  VitalDelayType := Basetype;
+               elsif Name_Compare (Decl, "vitaldelayarraytype") then
+                  VitalDelayArrayType := Basetype;
+               end if;
+            end if;
          end if;
       end loop;
       if Vhpi_Get_Kind (VitalDelayType01) = VhpiUndefined then
-         Error ("cannot found VitalDelayType01 in ieee.vital_timing");
+         Error ("cannot find VitalDelayType01 in ieee.vital_timing");
+         return;
+      end if;
+      if Vhpi_Get_Kind (VitalDelayArrayType01) = VhpiUndefined then
+         Error ("cannot find VitalDelayArrayType01 in ieee.vital_timing");
+         return;
+      end if;
+      if Vhpi_Get_Kind (VitalDelayType) = VhpiUndefined then
+         Error ("cannot find VitalDelayType in ieee.vital_timing");
          return;
       end if;
    end Extract_Vital_Delay_Type;
diff -urN ghdl-0.26/vhdl/grt/grt-vpi.adb ghdl-0.26dev/vhdl/grt/grt-vpi.adb
--- ghdl-0.26/vhdl/grt/grt-vpi.adb	2006-07-29 21:50:59.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-vpi.adb	2008-06-02 23:50:40.000000000 +0200
@@ -661,27 +661,33 @@
       -- Checks the format of aValue. Only vpiBinStrVal will be accepted
       --  for now.
       case aValue.Format is
-         when vpiObjTypeVal=>
+         when vpiObjTypeVal =>
             dbgPut_Line ("vpi_put_value: vpiObjTypeVal");
-         when vpiBinStrVal=>
+         when vpiBinStrVal =>
             ii_vpi_put_value_bin_str(aObj.Ref, aValue.Str);
-            dbgPut_Line ("vpi_put_value: vpiBinStrVal");
-         when vpiOctStrVal=>
+            -- dbgPut_Line ("vpi_put_value: vpiBinStrVal");
+         when vpiOctStrVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiOctStrVal");
-         when vpiDecStrVal=>
+         when vpiDecStrVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiDecStrVal");
-         when vpiHexStrVal=>
+         when vpiHexStrVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiHexStrVal");
-         when vpiScalarVal=>
+         when vpiScalarVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiScalarVal");
-         when vpiIntVal=>
+         when vpiIntVal =>
             dbgPut_Line ("vpi_put_value: vpiIntVal");
-         when vpiRealVal=>     dbgPut_Line("vpi_put_value: vpiRealVal");
-         when vpiStringVal=>   dbgPut_Line("vpi_put_value: vpiStringVal");
-         when vpiTimeVal=>     dbgPut_Line("vpi_put_value: vpiTimeVal");
-         when vpiVectorVal=>   dbgPut_Line("vpi_put_value: vpiVectorVal");
-         when vpiStrengthVal=> dbgPut_Line("vpi_put_value: vpiStrengthVal");
-         when others=>         dbgPut_Line("vpi_put_value: unknown mFormat");
+         when vpiRealVal =>
+            dbgPut_Line("vpi_put_value: vpiRealVal");
+         when vpiStringVal =>
+            dbgPut_Line("vpi_put_value: vpiStringVal");
+         when vpiTimeVal =>
+            dbgPut_Line("vpi_put_value: vpiTimeVal");
+         when vpiVectorVal =>
+            dbgPut_Line("vpi_put_value: vpiVectorVal");
+         when vpiStrengthVal =>
+            dbgPut_Line("vpi_put_value: vpiStrengthVal");
+         when others =>
+            dbgPut_Line("vpi_put_value: unknown mFormat");
       end case;
 
       -- Must return a scheduled event caused by vpi_put_value()
diff -urN ghdl-0.26/vhdl/grt/grt-vpi.ads ghdl-0.26dev/vhdl/grt/grt-vpi.ads
--- ghdl-0.26/vhdl/grt/grt-vpi.ads	2005-09-23 00:18:14.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-vpi.ads	2008-06-02 23:50:40.000000000 +0200
@@ -79,10 +79,10 @@
    --   double real;
    -- } s_vpi_time, *p_vpi_time;
    type s_vpi_time is record
-      mType : integer;
-      mHigh : integer; -- this should be unsigned
-      mLow :  integer; -- this should be unsigned
-      mReal : float;   -- this should be double
+      mType : Integer;
+      mHigh : Integer; -- this should be unsigned
+      mLow :  Integer; -- this should be unsigned
+      mReal : Float;   -- this should be double
    end record;
    type p_vpi_time is access s_vpi_time;
 
diff -urN ghdl-0.26/vhdl/grt/grt-waves.adb ghdl-0.26dev/vhdl/grt/grt-waves.adb
--- ghdl-0.26/vhdl/grt/grt-waves.adb	2006-06-21 21:01:39.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-waves.adb	2008-06-02 23:50:40.000000000 +0200
@@ -62,7 +62,7 @@
    Ghw_Hie_Port_Buffer  : constant Unsigned_8 := 20; --  Port
    Ghw_Hie_Port_Linkage : constant Unsigned_8 := 21; --  Port
 
-   --  Return TRUE if OPT is an option for VCD.
+   --  Return TRUE if OPT is an option for wave.
    function Wave_Option (Opt : String) return Boolean
    is
       F : Natural := Opt'First;
@@ -842,7 +842,7 @@
 
    procedure Write_Hierarchy_El (Decl : VhpiHandleT)
    is
-      Mode2hie : constant array (VhpiModeP) of Unsigned_8 :=
+      Mode2hie : constant array (VhpiModeT) of Unsigned_8 :=
         (VhpiErrorMode => Ghw_Hie_Signal,
          VhpiInMode => Ghw_Hie_Port_In,
          VhpiOutMode => Ghw_Hie_Port_Out,
diff -urN ghdl-0.26/vhdl/iirs_utils.adb ghdl-0.26dev/vhdl/iirs_utils.adb
--- ghdl-0.26/vhdl/iirs_utils.adb	2006-09-26 02:18:16.000000000 +0200
+++ ghdl-0.26dev/vhdl/iirs_utils.adb	2008-06-02 23:50:48.000000000 +0200
@@ -827,7 +827,9 @@
               | Iir_Kind_Function_Call =>
                return False;
             when Iir_Kind_Signal_Declaration
-              | Iir_Kind_Signal_Interface_Declaration =>
+              | Iir_Kind_Signal_Interface_Declaration
+              | Iir_Kind_Guard_Signal_Declaration
+              | Iir_Kinds_Signal_Attribute =>
                return True;
             when Iir_Kind_Object_Alias_Declaration =>
                Adecl := Get_Base_Name (Get_Name (Adecl));
diff -urN ghdl-0.26/vhdl/Makefile.in ghdl-0.26dev/vhdl/Makefile.in
--- ghdl-0.26/vhdl/Makefile.in	2007-04-08 18:46:39.000000000 +0200
+++ ghdl-0.26dev/vhdl/Makefile.in	2008-06-02 23:54:25.000000000 +0200
@@ -456,6 +456,10 @@
   GRT_EXTRA_LIB=-lm $(GRT_ELF_OPTS)
   ADAC=gnatgcc
 endif
+ifeq ($(filter-out i%86 darwin%,$(arch) $(osys)),)
+  GRT_TARGET_OBJS=i386.o linux.o times.o
+  GRT_EXTRA_LIB=-lm
+endif
 ifeq ($(filter-out sparc solaris%,$(arch) $(osys)),)
   GRT_TARGET_OBJS=sparc.o linux.o times.o
   GRT_EXTRA_LIB=-ldl -lm
@@ -471,9 +475,10 @@
 ifeq ($(filter-out i%86 mingw32,$(arch) $(osys)),)
   GRT_TARGET_OBJS=win32.o clock.o
 endif
-ifeq ($(filter-out i%86 cygwin,$(arch) $(osys)),)
-  GRT_TARGET_OBJS=win32.o clock.o
-endif
+# Doesn't work for unknown reasons.
+#ifeq ($(filter-out i%86 cygwin,$(arch) $(osys)),)
+#  GRT_TARGET_OBJS=win32.o clock.o
+#endif
 # Fall-back: use a generic implementation based on pthreads.
 ifndef GRT_TARGET_OBJS
   GRT_TARGET_OBJS=pthread.o times.o
@@ -541,6 +546,9 @@
 win32.o: $(GRTSRCDIR)/config/win32.c
 	$(CC) -c $(GRT_FLAGS) -o $@ $<
 
+win32thr.o: $(GRTSRCDIR)/config/win32thr.c
+	$(CC) -c $(GRT_FLAGS) -o $@ $<
+
 pthread.o: $(GRTSRCDIR)/config/pthread.c
 	$(CC) -c $(GRT_FLAGS) -o $@ $<
 
@@ -559,6 +567,12 @@
 grt-cthreads.o: $(GRTSRCDIR)/grt-cthreads.c
 	$(CC) -c $(GRT_FLAGS) -o $@ $<
 
+grt-disp-config:
+	@echo "target: $(target)"
+	@echo "targ: $(targ)"
+	@echo "arch: $(arch)"
+	@echo "osys: $(osys)"
+
 grt-files: run-bind.adb
 	sed -e "1,/-- *BEGIN/d" -e "/-- *END/,\$$d" \
 	  -e "s/   --   //" < $< > $@
diff -urN ghdl-0.26/vhdl/parse.adb ghdl-0.26dev/vhdl/parse.adb
--- ghdl-0.26/vhdl/parse.adb	2005-12-30 14:38:27.000000000 +0100
+++ ghdl-0.26dev/vhdl/parse.adb	2008-06-02 23:50:48.000000000 +0200
@@ -288,7 +288,7 @@
             end if;
             Scan.Scan;
             if Current_Token = Tok_Box then
-               Unexpected ("<> not allowed here");
+               Unexpected ("range expression expected");
                Scan.Scan;
                return Null_Iir;
             end if;
@@ -385,6 +385,12 @@
       end if;
       Scan.Scan;
 
+      if Current_Token = Tok_Box then
+         Error_Msg_Parse ("range constraint required");
+         Scan.Scan;
+         return Null_Iir;
+      end if;
+
       return Parse_Range;
    end Parse_Range_Constraint;
 
@@ -407,6 +413,9 @@
          when Tok_Range =>
             --  FIXME: create a subtype indication.
             Rng := Parse_Range_Constraint;
+            if Rng = Null_Iir then
+               return Left;
+            end if;
             Set_Type (Rng, Left);
             return Rng;
          when others =>
diff -urN ghdl-0.26/vhdl/sem_decls.adb ghdl-0.26dev/vhdl/sem_decls.adb
--- ghdl-0.26/vhdl/sem_decls.adb	2006-09-26 01:58:43.000000000 +0200
+++ ghdl-0.26dev/vhdl/sem_decls.adb	2008-06-02 23:50:48.000000000 +0200
@@ -654,8 +654,7 @@
                     (Name_Op_Less_Equal, Iir_Predefined_Array_Less_Equal);
                end if;
 
-               Element_Type :=
-                 Get_Base_Type (Get_Element_Subtype (Type_Definition));
+               Element_Type := Get_Element_Subtype (Type_Definition);
 
                Add_Operation (Name_Op_Concatenation,
                               Iir_Predefined_Array_Array_Concat,
diff -urN ghdl-0.26/vhdl/sem_expr.adb ghdl-0.26dev/vhdl/sem_expr.adb
--- ghdl-0.26/vhdl/sem_expr.adb	2007-03-24 08:37:15.000000000 +0100
+++ ghdl-0.26dev/vhdl/sem_expr.adb	2008-06-02 23:50:48.000000000 +0200
@@ -168,7 +168,8 @@
            | Iir_Kind_Library_Clause
            | Iir_Kind_Component_Declaration
            | Iir_Kinds_Procedure_Declaration
-           | Iir_Kind_Range_Array_Attribute =>
+           | Iir_Kind_Range_Array_Attribute
+           | Iir_Kind_Element_Declaration =>
             Error_Msg_Sem (Disp_Node (Expr)
                            & " not allowed in an expression", Loc);
             return Null_Iir;
@@ -2739,7 +2740,8 @@
 
          when Iir_Kind_String_Literal
            | Iir_Kind_Bit_String_Literal =>
-            Len := Sem_String_Literal (Aggr, Get_Element_Subtype (A_Type));
+            Len := Sem_String_Literal
+              (Aggr, Get_Base_Type (Get_Element_Subtype (A_Type)));
             Assoc_Chain := Null_Iir;
             Info.Min_Length := Integer'Max (Info.Min_Length, Len);
             Is_Positional := True;
@@ -2825,14 +2827,21 @@
             --  index subtype of the aggregate and the smallest and largest
             --  choice given.
             if Choice_Staticness = Locally then
-               case Get_Direction (Index_Constraint) is
-                  when Iir_To =>
-                     Set_Left_Limit (Index_Subtype_Constraint, Low);
-                     Set_Right_Limit (Index_Subtype_Constraint, High);
-                  when Iir_Downto =>
-                     Set_Left_Limit (Index_Subtype_Constraint, High);
-                     Set_Right_Limit (Index_Subtype_Constraint, Low);
-               end case;
+               if Low = Null_Iir or High = Null_Iir then
+                  --  Avoid error propagation.
+                  Set_Range_Constraint (Info.Index_Subtype,
+                                        Get_Range_Constraint (Index_Type));
+                  Free_Iir (Index_Subtype_Constraint);
+               else
+                  case Get_Direction (Index_Constraint) is
+                     when Iir_To =>
+                        Set_Left_Limit (Index_Subtype_Constraint, Low);
+                        Set_Right_Limit (Index_Subtype_Constraint, High);
+                     when Iir_Downto =>
+                        Set_Left_Limit (Index_Subtype_Constraint, High);
+                        Set_Right_Limit (Index_Subtype_Constraint, Low);
+                  end case;
+               end if;
             else
                --  Dynamic aggregate.
                declare
diff -urN ghdl-0.26/vhdl/sem_names.adb ghdl-0.26dev/vhdl/sem_names.adb
--- ghdl-0.26/vhdl/sem_names.adb	2007-03-28 00:36:16.000000000 +0200
+++ ghdl-0.26dev/vhdl/sem_names.adb	2008-06-02 23:50:48.000000000 +0200
@@ -1573,7 +1573,8 @@
            | Iir_Kind_Selected_Element
            | Iir_Kind_Dereference
            | Iir_Kind_Implicit_Dereference
-           | Iir_Kind_Attribute_Value =>
+           | Iir_Kind_Attribute_Value
+           | Iir_Kind_Function_Call =>
             if Get_Kind (Get_Type (Prefix))
               = Iir_Kind_Protected_Type_Declaration
             then
diff -urN ghdl-0.26/vhdl/translation.adb ghdl-0.26dev/vhdl/translation.adb
--- ghdl-0.26/vhdl/translation.adb	2007-03-14 00:12:38.000000000 +0100
+++ ghdl-0.26dev/vhdl/translation.adb	2008-06-02 23:50:40.000000000 +0200
@@ -11047,6 +11047,10 @@
          Push_Identifier_Prefix
            (Mark3, Get_Identifier (Get_Base_Name (Formal)));
 
+         if Is_Anonymous_Type_Definition (In_Type) then
+            In_Type := Get_Base_Type (In_Type);
+         end if;
+
          Out_Info := Get_Info (Out_Type);
          In_Info := Get_Info (In_Type);
 
@@ -11794,15 +11798,16 @@
       begin
          Obj := Sem_Names.Name_To_Object (Expr);
          if Obj /= Null_Iir then
-            case Get_Kind (Get_Base_Name (Obj)) is
-               when Iir_Kind_Signal_Declaration
-                 | Iir_Kind_Signal_Interface_Declaration
-                 | Iir_Kind_Guard_Signal_Declaration
-                 | Iir_Kinds_Signal_Attribute =>
-                  return True;
-               when others =>
-                  return False;
-            end case;
+            return Is_Signal_Object (Obj);
+--              case Get_Kind (Get_Base_Name (Obj)) is
+--                 when Iir_Kind_Signal_Declaration
+--                   | Iir_Kind_Signal_Interface_Declaration
+--                   | Iir_Kind_Guard_Signal_Declaration
+--                   | Iir_Kinds_Signal_Attribute =>
+--                    return True;
+--                 when others =>
+--                    return False;
+--              end case;
          else
             return False;
          end if;
@@ -26794,9 +26799,9 @@
                     (Mark, Name_Table.Get_Identifier ("DEFAULT_CONFIG"));
                   Chap1.Translate_Configuration_Declaration (El);
                   Pop_Identifier_Prefix (Mark);
-                  Pop_Identifier_Prefix (Mark_Entity);
-                  Pop_Identifier_Prefix (Mark_Sep);
                   Pop_Identifier_Prefix (Mark_Arch);
+                  Pop_Identifier_Prefix (Mark_Sep);
+                  Pop_Identifier_Prefix (Mark_Entity);
                end;
             else
                Chap1.Translate_Configuration_Declaration (El);
@@ -28308,6 +28313,7 @@
          Assoc : O_Assoc_List;
          Instance : O_Dnode;
          Arch_Instance : O_Dnode;
+         Mark : Id_Mark_Type;
       begin
          Arch_Info := Get_Info (Arch);
          Entity_Info := Get_Info (Entity);
@@ -28376,6 +28382,7 @@
 
          --  init instance
          Push_Scope (Entity_Info.Block_Decls_Type, Instance);
+         Push_Identifier_Prefix (Mark, "");
          Chap1.Translate_Entity_Init (Entity);
 
          --  elab instance
@@ -28390,6 +28397,7 @@
          New_Association (Assoc, New_Obj_Value (Arch_Instance));
          New_Procedure_Call (Assoc);
 
+         Pop_Identifier_Prefix (Mark);
          Pop_Scope (Entity_Info.Block_Decls_Type);
          Finish_Subprogram_Body;
 
diff -urN ghdl-0.26/vhdl/types.ads ghdl-0.26dev/vhdl/types.ads
--- ghdl-0.26/vhdl/types.ads	2005-09-22 23:23:20.000000000 +0200
+++ ghdl-0.26dev/vhdl/types.ads	2008-06-02 23:50:48.000000000 +0200
@@ -121,4 +121,9 @@
    --  Self-explaining: raised when an internal error (such as consistency)
    --  is detected.
    Internal_Error: exception;
+
+   --  In some case, a low level subprogram can't handle error
+   --  (e.g eval_pos).  In this case it is easier to raise an exception and
+   --  let upper level subprograms handle the case.
+   Node_Error : exception;
 end Types;
diff -urN ghdl-0.26/vhdl/version.ads ghdl-0.26dev/vhdl/version.ads
--- ghdl-0.26/vhdl/version.ads	2007-04-08 18:43:04.000000000 +0200
+++ ghdl-0.26dev/vhdl/version.ads	2008-06-02 23:50:48.000000000 +0200
@@ -1,5 +1,5 @@
 package Version is
    Ghdl_Release : constant String :=
-      "GHDL 0.26 (20070408) [Sokcho edition]";
+      "GHDL 0.26dev (20070408) [Sokcho edition]";
    Ghdl_Ver : constant String := "0.26";
 end Version;
