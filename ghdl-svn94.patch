diff -urN ghdl-0.26/vhdl/evaluation.adb ghdl-0.26dev/vhdl/evaluation.adb
--- ghdl-0.26/vhdl/evaluation.adb	2007-03-24 08:33:02.000000000 +0100
+++ ghdl-0.26dev/vhdl/evaluation.adb	2008-05-16 11:27:54.000000000 +0200
@@ -2020,6 +2020,10 @@
       --  Should check L <= R or L >= R according to direction.
       --return Eval_Is_In_Bound (Get_Left_Limit (A_Range), Sub_Type)
       --  and then Eval_Is_In_Bound (Get_Right_Limit (A_Range), Sub_Type);
+   exception
+      when Node_Error =>
+         --  Avoid error storms.
+         return True;
    end Eval_Is_Range_In_Bound;
 
    procedure Eval_Check_Range
@@ -2091,6 +2095,8 @@
             return Get_Physical_Value (Expr);
          when Iir_Kind_Unit_Declaration =>
             return Get_Value (Get_Physical_Unit_Value (Expr));
+         when Iir_Kind_Error =>
+            raise Node_Error;
          when others =>
             Error_Kind ("eval_pos", Expr);
       end case;
diff -urN ghdl-0.26/vhdl/grt/config/i386.S ghdl-0.26dev/vhdl/grt/config/i386.S
--- ghdl-0.26/vhdl/grt/config/i386.S	2005-09-23 00:39:19.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/config/i386.S	2008-05-16 11:27:49.000000000 +0200
@@ -21,21 +21,30 @@
 	
 	.text
 
-	/* Function called to loop on the process.  */	
-	.align 4
-	.type	grt_stack_loop,@function
-grt_stack_loop:	
+#ifdef __ELF__
+#define ENTRY(func) .align 4; .globl func; .type func,@function; func:
+#define END(func) .size func, . - func
+#define NAME(name) name
+#elif __APPLE__
+#define ENTRY(func) .align 4; .globl _##func; _##func:
+#define END(func)
+#define NAME(name) _##name
+#else
+#define ENTRY(func) .align 4; func:
+#define END(func)
+#define NAME(name) name
+#endif
+	
+	/* Function called to loop on the process.  */
+ENTRY(grt_stack_loop)
 	call	*4(%esp)
-	jmp	grt_stack_loop
-	.size	grt_stack_loop, . - grt_stack_loop
+	jmp	NAME(grt_stack_loop)
+END(grt_stack_loop)
 
 	/* function Stack_Create (Func : Address; Arg : Address)
  	                          return Stack_Type;
 	*/
-	.align	4
-	.globl grt_stack_create
-	.type	 grt_stack_create,@function
-grt_stack_create:
+ENTRY(grt_stack_create)
 	/* Standard prologue.  */
 	pushl	%ebp
 	movl	%esp,%ebp
@@ -43,7 +52,7 @@
 	subl	$8,%esp
 	
 	/* Allocate the stack, and exit in case of failure  */
-	call	grt_stack_allocate
+	call	NAME(grt_stack_allocate)
 	testl	%eax,%eax
 	je	.Ldone
 
@@ -58,7 +67,7 @@
 	movl	12(%ebp), %ecx
 	movl	%ecx, -8(%eax)
 	/* The return function.  */
-	movl	$grt_stack_loop, -12(%eax)
+	movl	$NAME(grt_stack_loop), -12(%eax)
 	/* The context.  */
 	movl	%ebx, -16(%eax)
 	movl	%esi, -20(%eax)
@@ -72,16 +81,12 @@
 .Ldone:
 	leave
 	ret
-	.size	 grt_stack_create,. - grt_stack_create
-
+END(grt_stack_create)
 
 
-	.align 4
-	.globl grt_stack_switch
 	/* Arguments:	TO, FROM
 	   Both are pointers to a stack_context.  */
-	.type	 grt_stack_switch,@function
-grt_stack_switch:
+ENTRY(grt_stack_switch)
 	/* TO -> ECX.  */
 	movl	4(%esp), %ecx
 	/* FROM -> EDX.  */
@@ -102,7 +107,7 @@
 	popl	%ebx
 	/* Run.  */
 	ret
-	.size	 grt_stack_switch, . - grt_stack_switch
+END(grt_stack_switch)
 
 	
 	.ident	"Written by T.Gingold"
diff -urN ghdl-0.26/vhdl/grt/config/linux.c ghdl-0.26dev/vhdl/grt/config/linux.c
--- ghdl-0.26/vhdl/grt/config/linux.c	2006-03-09 03:26:31.000000000 +0100
+++ ghdl-0.26dev/vhdl/grt/config/linux.c	2008-05-16 11:27:49.000000000 +0200
@@ -25,6 +25,10 @@
 #include <stdlib.h>
 //#include <stdint.h>
 
+#ifdef __APPLE__
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
 /* On x86, the stack growns downward.  */
 #define STACK_GROWNS_DOWNWARD 1
 
diff -urN ghdl-0.26/vhdl/grt/config/pthread.c ghdl-0.26dev/vhdl/grt/config/pthread.c
--- ghdl-0.26/vhdl/grt/config/pthread.c	2006-03-10 02:49:44.000000000 +0100
+++ ghdl-0.26dev/vhdl/grt/config/pthread.c	2008-05-16 11:27:49.000000000 +0200
@@ -28,6 +28,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <setjmp.h>
+#include <assert.h>
 
 //#define INFO printf
 #define INFO (void)
@@ -35,10 +36,14 @@
 // GHDL names an endless loop calling FUNC with ARG a 'stack'
 // at a given time, only one stack may be 'executed'
 typedef struct 
-{	pthread_t           thread;         // stack's thread
-	pthread_mutex_t     mutex;          // mutex to suspend/resume thread
-	void                (*Func)(void*); // stack's FUNC
-	void*               Arg;            // ARG passed to FUNC
+{	
+  pthread_t           thread;         // stack's thread
+  pthread_mutex_t     mutex;          // mutex to suspend/resume thread
+#if defined(__CYGWIN__)
+  pthread_mutexattr_t mxAttr;
+#endif
+  void                (*Func)(void*); // stack's FUNC
+  void*               Arg;            // ARG passed to FUNC
 } Stack_Type_t, *Stack_Type;
 
 static Stack_Type_t      main_stack_context;
@@ -51,40 +56,56 @@
 // This may adjust stack sizes.
 // Must be called after grt.options.decode.
 // => procedure Stack_Init;
-{	INFO("grt_stack_init\n");
-	INFO("  main_stack_context=0x%08x\n", &main_stack_context);
+{
+  int res;
+  INFO("grt_stack_init\n");
+  INFO("  main_stack_context=0x%08x\n", &main_stack_context);
 	
-	pthread_mutex_init(&(main_stack_context.mutex), NULL);
 
-	// lock the mutex, as we are currently running
-	pthread_mutex_lock(&(main_stack_context.mutex));
+#if defined(__CYGWIN__)
+  res = pthread_mutexattr_init (&main_stack_context.mxAttr);
+  assert (res == 0);
+  res = pthread_mutexattr_settype (&main_stack_context.mxAttr,
+				   PTHREAD_MUTEX_DEFAULT);
+  assert (res == 0);
+  res = pthread_mutex_init (&main_stack_context.mutex,
+			    &main_stack_context.mxAttr);
+  assert (res == 0);
+#else
+  res = pthread_mutex_init (&main_stack_context.mutex, NULL);
+  assert (res == 0);
+#endif
+  // lock the mutex, as we are currently running
+  res = pthread_mutex_lock (&main_stack_context.mutex);
+  assert (res == 0);
 	
-	current = &main_stack_context;
+  current = &main_stack_context;
 
-	grt_set_main_stack (&main_stack_context);
+  grt_set_main_stack (&main_stack_context);
 }
 
 //----------------------------------------------------------------------------
 static void* grt_stack_loop(void* pv_myStack)
 {
-	Stack_Type myStack= (Stack_Type)pv_myStack;
+  Stack_Type myStack= (Stack_Type)pv_myStack;
 
-	INFO("grt_stack_loop\n");
+  INFO("grt_stack_loop\n");
 	
-	INFO("  myStack=0x%08x\n", myStack);
+  INFO("  myStack=0x%08x\n", myStack);
 
-	// block until mutex becomes available again.
-	// this happens when this stack is enabled for the first time
-	pthread_mutex_lock(&(myStack->mutex));
+  // block until mutex becomes available again.
+  // this happens when this stack is enabled for the first time
+  pthread_mutex_lock(&(myStack->mutex));
 	
-	// run stack's function in endless loop
-	while(1)
-	{	INFO("  call 0x%08x with 0x%08x\n", myStack->Func, myStack->Arg);
-		myStack->Func(myStack->Arg);
-	}
+  // run stack's function in endless loop
+  while(1)
+    {
+      INFO("  call 0x%08x with 0x%08x\n", myStack->Func, myStack->Arg);
+      myStack->Func(myStack->Arg);
+    }
 	
-	// we never get here...
-	return 0;
+  // we never get here...
+  return 0;
 }
 
 //----------------------------------------------------------------------------
@@ -93,29 +114,41 @@
 // an argument ARG.
 // => function Stack_Create (Func : Address; Arg : Address) return Stack_Type;
 {
-  	Stack_Type newStack;
+  Stack_Type newStack;
+  int res;
 
-	INFO("grt_stack_create\n");
-	INFO("  call 0x%08x with 0x%08x\n", Func, Arg);
+  INFO("grt_stack_create\n");
+  INFO("  call 0x%08x with 0x%08x\n", Func, Arg);
 			
-	newStack= malloc(sizeof(Stack_Type_t));
+  newStack = malloc (sizeof(Stack_Type_t));
 	
-	// init function and argument
-	newStack->Func= Func;
-	newStack->Arg=  Arg;
+  // init function and argument
+  newStack->Func = Func;
+  newStack->Arg = Arg;
+	
+  // create mutex
+#if defined(__CYGWIN__)
+  res = pthread_mutexattr_init (&newStack->mxAttr);
+  assert (res == 0);
+  res = pthread_mutexattr_settype (&newStack->mxAttr, PTHREAD_MUTEX_DEFAULT);
+  assert (res == 0);
+  res = pthread_mutex_init (&newStack->mutex, &newStack->mxAttr);
+  assert (res == 0);
+#else
+  res = pthread_mutex_init (&newStack->mutex, NULL);
+  assert (res == 0);
+#endif
+	
+  // block the mutex, so that thread will blocked in grt_stack_loop
+  res = pthread_mutex_lock (&newStack->mutex);
+  assert (res == 0);
+  
+  INFO("  newStack=0x%08x\n", newStack);
 	
-	// create mutex
-	pthread_mutex_init(&(newStack->mutex), NULL);
+  // create thread, which executes grt_stack_loop
+  pthread_create (&newStack->thread, NULL, grt_stack_loop, newStack); 
 	
-	// block the mutex, so that thread will blocked in grt_stack_loop
-	pthread_mutex_lock(&(newStack->mutex));
-	
-	INFO("  newStack=0x%08x\n", newStack);
-	
-	// create thread, which executes grt_stack_loop
-	pthread_create(&(newStack->thread), NULL, grt_stack_loop, newStack); 
-	
-	return newStack;
+  return newStack;
 }
 
 static int need_longjmp;
@@ -127,30 +160,35 @@
 // Resume stack TO and save the current context to the stack pointed by
 // CUR.
 // => procedure Stack_Switch (To : Stack_Type; From : Stack_Type);
-{	INFO("grt_stack_switch\n");
-	INFO("  from 0x%08x to 0x%08x\n", From, To);
+{	
+  int res;
+  INFO("grt_stack_switch\n");
+  INFO("  from 0x%08x to 0x%08x\n", From, To);
 
-	current = To;
+  current = To;
 
-	// unlock 'To' mutex. this will make the other thread either
-	// - starts for first time in grt_stack_loop
-	// - resumes at lock below
-	pthread_mutex_unlock(&(To->mutex));
+  // unlock 'To' mutex. this will make the other thread either
+  // - starts for first time in grt_stack_loop
+  // - resumes at lock below
+  res = pthread_mutex_unlock (&To->mutex);
+  assert (res == 0);
 		
-	// block until 'From' mutex becomes available again
-	// as we are running, our mutex is locked and we block here
-	// when stacks are switched, with above unlock, we may proceed
-	pthread_mutex_lock(&(From->mutex));
+  // block until 'From' mutex becomes available again
+  // as we are running, our mutex is locked and we block here
+  // when stacks are switched, with above unlock, we may proceed
+  res = pthread_mutex_lock (&From->mutex);
+  assert (res == 0);
 
-	if (From == &main_stack_context && need_longjmp != 0)
-	  longjmp (run_env, need_longjmp);
+  if (From == &main_stack_context && need_longjmp != 0)
+    longjmp (run_env, need_longjmp);
 }
 
 //----------------------------------------------------------------------------
 void grt_stack_delete(Stack_Type Stack)
 // Delete stack STACK, which must not be currently executed.
 // => procedure Stack_Delete (Stack : Stack_Type);
-{	INFO("grt_stack_delete\n");
+{	
+  INFO("grt_stack_delete\n");
 }
 
 void
diff -urN ghdl-0.26/vhdl/grt/config/win32thr.c ghdl-0.26dev/vhdl/grt/config/win32thr.c
--- ghdl-0.26/vhdl/grt/config/win32thr.c	1970-01-01 01:00:00.000000000 +0100
+++ ghdl-0.26dev/vhdl/grt/config/win32thr.c	2008-05-16 11:27:49.000000000 +0200
@@ -0,0 +1,167 @@
+/*  GRT stack implementation for Win32
+    Copyright (C) 2004, 2005 Felix Bertram.
+
+    GHDL is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License as published by the Free
+    Software Foundation; either version 2, or (at your option) any later
+    version.
+
+    GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+    WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+    for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with GCC; see the file COPYING.  If not, write to the Free
+    Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+    02111-1307, USA.
+*/
+//-----------------------------------------------------------------------------
+// Project:     GHDL - VHDL Simulator
+// Description: Win32 port of stacks package
+// Note:        Tristan's original i386/Linux used assembly-code 
+//              to manually switch stacks for performance reasons.
+// History:     2004feb09, FB, created.
+//-----------------------------------------------------------------------------
+
+#include <windows.h>
+//#include <pthread.h>
+//#include <stdlib.h>
+//#include <stdio.h>
+
+
+//#define INFO printf
+#define INFO (void)
+
+// GHDL names an endless loop calling FUNC with ARG a 'stack'
+// at a given time, only one stack may be 'executed'
+typedef struct 
+{	HANDLE              thread;         // stack's thread
+	HANDLE              mutex;          // mutex to suspend/resume thread
+	void                (*Func)(void*); // stack's FUNC
+	void*               Arg;            // ARG passed to FUNC
+} Stack_Type_t, *Stack_Type;
+
+
+static Stack_Type_t      main_stack_context;
+extern void grt_set_main_stack (Stack_Type_t *stack);
+
+//------------------------------------------------------------------------------
+void grt_stack_init(void)
+// Initialize the stacks package.
+// This may adjust stack sizes.
+// Must be called after grt.options.decode.
+// => procedure Stack_Init;
+{	INFO("grt_stack_init\n");
+	INFO("  main_stack_context=0x%08x\n", &main_stack_context);
+
+	// create event. reset event, as we are currently running
+	main_stack_context.mutex = CreateEvent(NULL,  // lpsa
+	                                       FALSE, // fManualReset
+	                                       FALSE, // fInitialState
+	                                       NULL); // lpszEventName
+
+	grt_set_main_stack (&main_stack_context);
+}
+
+//------------------------------------------------------------------------------
+static unsigned long __stdcall grt_stack_loop(void* pv_myStack)
+{
+	Stack_Type myStack= (Stack_Type)pv_myStack;
+
+	INFO("grt_stack_loop\n");
+	
+	INFO("  myStack=0x%08x\n", myStack);
+
+	// block until event becomes set again.
+	// this happens when this stack is enabled for the first time
+	WaitForSingleObject(myStack->mutex, INFINITE);
+	
+	// run stack's function in endless loop
+	while(1)
+	{	INFO("  call 0x%08x with 0x%08x\n", myStack->Func, myStack->Arg);
+		myStack->Func(myStack->Arg);
+	}
+	
+	// we never get here...
+	return 0;
+}
+
+//------------------------------------------------------------------------------
+Stack_Type grt_stack_create(void* Func, void* Arg) 
+// Create a new stack, which on first execution will call FUNC with
+// an argument ARG.
+// => function Stack_Create (Func : Address; Arg : Address) return Stack_Type;
+{  	Stack_Type newStack;
+	DWORD      m_IDThread; // Thread's ID (dummy)
+
+	INFO("grt_stack_create\n");
+	INFO("  call 0x%08x with 0x%08x\n", Func, Arg);
+			
+	newStack= malloc(sizeof(Stack_Type_t));
+	
+	// init function and argument
+	newStack->Func= Func;
+	newStack->Arg=  Arg;
+	
+	// create event. reset event, so that thread will blocked in grt_stack_loop
+	newStack->mutex= CreateEvent(NULL,  // lpsa
+	                             FALSE, // fManualReset
+	                             FALSE, // fInitialState
+	                             NULL); // lpszEventName
+	
+	INFO("  newStack=0x%08x\n", newStack);
+	
+	// create thread, which executes grt_stack_loop
+	newStack->thread= CreateThread(NULL,           // lpsa
+	                               0,              // cbStack
+	                               grt_stack_loop, // lpStartAddr
+	                               newStack,       // lpvThreadParm
+	                               0,              // fdwCreate
+	                               &m_IDThread);   // lpIDThread
+	
+	return newStack;
+}
+
+//------------------------------------------------------------------------------
+void grt_stack_switch(Stack_Type To, Stack_Type From)
+// Resume stack TO and save the current context to the stack pointed by
+// CUR.
+// => procedure Stack_Switch (To : Stack_Type; From : Stack_Type);
+{	INFO("grt_stack_switch\n");
+	INFO("  from 0x%08x to 0x%08x\n", From, To);
+	
+	// set 'To' event. this will make the other thread either
+	// - start for first time in grt_stack_loop
+	// - resume at WaitForSingleObject below
+	SetEvent(To->mutex);
+		
+	// block until 'From' event becomes set again
+	// as we are running, our event is reset and we block here
+	// when stacks are switched, with above SetEvent, we may proceed
+	WaitForSingleObject(From->mutex, INFINITE);
+}
+
+//------------------------------------------------------------------------------
+void grt_stack_delete(Stack_Type Stack)
+// Delete stack STACK, which must not be currently executed.
+// => procedure Stack_Delete (Stack : Stack_Type);
+{	INFO("grt_stack_delete\n");
+}
+
+//----------------------------------------------------------------------------
+#ifndef WITH_GNAT_RUN_TIME
+void __gnat_raise_storage_error(void)
+{
+   abort ();
+}
+
+void __gnat_raise_program_error(void)
+{
+   abort ();
+}
+#endif
+
+//----------------------------------------------------------------------------
+// end of file
+
diff -urN ghdl-0.26/vhdl/grt/grt-errors.adb ghdl-0.26dev/vhdl/grt/grt-errors.adb
--- ghdl-0.26/vhdl/grt/grt-errors.adb	2005-09-23 00:26:39.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-errors.adb	2008-05-16 11:27:50.000000000 +0200
@@ -125,6 +125,16 @@
       Newline_Err;
    end Report_E;
 
+   procedure Report_E (Str : Std_String_Ptr)
+   is
+      subtype Ada_Str is String (1 .. Natural (Str.Bounds.Dim_1.Length));
+   begin
+      if Ada_Str'Length > 0 then
+         Put_Err (Ada_Str (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+      end if;
+      Newline_Err;
+   end Report_E;
+
    procedure Error_H is
    begin
       Put_Err (Progname);
@@ -193,6 +203,13 @@
       Fatal_Error;
    end Error_E;
 
+   procedure Error_E_Std (Str : Std_String_Uncons)
+   is
+      subtype Str_Subtype is String (1 .. Str'Length);
+   begin
+      Error_E (Str_Subtype (Str));
+   end Error_E_Std;
+
    procedure Error (Str : String) is
    begin
       Error_H;
diff -urN ghdl-0.26/vhdl/grt/grt-errors.ads ghdl-0.26dev/vhdl/grt/grt-errors.ads
--- ghdl-0.26/vhdl/grt/grt-errors.ads	2005-09-23 00:26:29.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-errors.ads	2008-05-16 11:27:50.000000000 +0200
@@ -27,6 +27,7 @@
    procedure Error_C (Str : Ghdl_C_String);
    --procedure Error_C (Inst : Ghdl_Instance_Name_Acc);
    procedure Error_E (Str : String);
+   procedure Error_E_Std (Str : Std_String_Uncons);
    pragma No_Return (Error_E);
 
    --  Multi-call report procedure.  Do not exit at end.
@@ -36,6 +37,7 @@
    procedure Report_C (N : Integer);
    procedure Report_Now_C;
    procedure Report_E (Str : String);
+   procedure Report_E (Str : Std_String_Ptr);
 
    --  Complete error message.
    procedure Error (Str : String);
diff -urN ghdl-0.26/vhdl/grt/grt-files.adb ghdl-0.26dev/vhdl/grt/grt-files.adb
--- ghdl-0.26/vhdl/grt/grt-files.adb	2006-05-29 21:28:44.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-files.adb	2008-05-16 11:27:50.000000000 +0200
@@ -1,5 +1,5 @@
 --  GHDL Run Time (GRT) -  VHDL files subprograms.
---  Copyright (C) 2002, 2003, 2004, 2005 Tristan Gingold
+--  Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Tristan Gingold
 --
 --  GHDL is free software; you can redistribute it and/or modify it under
 --  the terms of the GNU General Public License as published by the Free
@@ -247,7 +247,7 @@
 
       if Res /= Open_Ok then
          Error_C ("open: cannot open text file ");
-         Error_E (String (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+         Error_E_Std (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1));
       end if;
    end Ghdl_Text_File_Open;
 
@@ -262,7 +262,7 @@
 
       if Res /= Open_Ok then
          Error_C ("open: cannot open file ");
-         Error_E (String (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+         Error_E_Std (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1));
       end if;
    end Ghdl_File_Open;
 
diff -urN ghdl-0.26/vhdl/grt/grt-lib.adb ghdl-0.26dev/vhdl/grt/grt-lib.adb
--- ghdl-0.26/vhdl/grt/grt-lib.adb	2006-08-11 05:09:50.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-lib.adb	2008-05-16 11:27:50.000000000 +0200
@@ -63,7 +63,7 @@
             Report_C ("???");
       end case;
       Report_C ("): ");
-      Report_E (String (Str.Base (0 .. Str.Bounds.Dim_1.Length - 1)));
+      Report_E (Str);
       if Level >= Grt.Options.Severity_Level then
          Error_C (Msg);
          Error_E (" failed");
diff -urN ghdl-0.26/vhdl/grt/grt-processes.adb ghdl-0.26dev/vhdl/grt/grt-processes.adb
--- ghdl-0.26/vhdl/grt/grt-processes.adb	2007-03-28 01:11:42.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-processes.adb	2008-05-16 11:27:50.000000000 +0200
@@ -111,6 +111,9 @@
    begin
       if State /= State_Sensitized then
          Stack := Stack_Create (Proc, This);
+         if Stack = Null_Stack then
+            Internal_Error ("cannot allocate stack: memory exhausted");
+         end if;
       else
          Stack := Null_Stack;
       end if;
diff -urN ghdl-0.26/vhdl/grt/grt-sdf.adb ghdl-0.26dev/vhdl/grt/grt-sdf.adb
--- ghdl-0.26/vhdl/grt/grt-sdf.adb	2005-10-08 14:06:15.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-sdf.adb	2008-05-16 11:27:50.000000000 +0200
@@ -315,7 +315,21 @@
                Pos := Pos + 1;
             when '/' =>
                Pos := Pos + 1;
-               return Tok_Div;
+               if Buf (Pos) = '/' then
+                  Pos := Pos + 1;
+                  --  Skip line comment.
+                  loop
+                     exit when Buf (Pos) = CR;
+                     exit when Buf (Pos) = LF;
+                     exit when Buf (Pos) = EOT;
+                     Pos := Pos + 1;
+                     if Pos >= Buf_Len then
+                        Refill_Buf;
+                     end if;
+                  end loop;
+               else
+                  return Tok_Div;
+               end if;
             when '.' =>
                Pos := Pos + 1;
                return Tok_Dot;
diff -urN ghdl-0.26/vhdl/grt/grt-types.ads ghdl-0.26dev/vhdl/grt/grt-types.ads
--- ghdl-0.26/vhdl/grt/grt-types.ads	2006-09-29 05:28:46.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-types.ads	2008-05-16 11:27:50.000000000 +0200
@@ -58,7 +58,8 @@
    end record;
 
    subtype Std_Character is Character;
-   type Std_String_Base is array (Ghdl_Index_Type) of Std_Character;
+   type Std_String_Uncons is array (Ghdl_Index_Type range <>) of Std_Character;
+   subtype Std_String_Base is Std_String_Uncons (Ghdl_Index_Type);
    type Std_String_Basep is access Std_String_Base;
 
    type Std_String_Bound is record
diff -urN ghdl-0.26/vhdl/grt/grt-vpi.adb ghdl-0.26dev/vhdl/grt/grt-vpi.adb
--- ghdl-0.26/vhdl/grt/grt-vpi.adb	2006-07-29 21:50:59.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-vpi.adb	2008-05-16 11:27:50.000000000 +0200
@@ -661,27 +661,33 @@
       -- Checks the format of aValue. Only vpiBinStrVal will be accepted
       --  for now.
       case aValue.Format is
-         when vpiObjTypeVal=>
+         when vpiObjTypeVal =>
             dbgPut_Line ("vpi_put_value: vpiObjTypeVal");
-         when vpiBinStrVal=>
+         when vpiBinStrVal =>
             ii_vpi_put_value_bin_str(aObj.Ref, aValue.Str);
-            dbgPut_Line ("vpi_put_value: vpiBinStrVal");
-         when vpiOctStrVal=>
+            -- dbgPut_Line ("vpi_put_value: vpiBinStrVal");
+         when vpiOctStrVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiOctStrVal");
-         when vpiDecStrVal=>
+         when vpiDecStrVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiDecStrVal");
-         when vpiHexStrVal=>
+         when vpiHexStrVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiHexStrVal");
-         when vpiScalarVal=>
+         when vpiScalarVal =>
             dbgPut_Line ("vpi_put_value: vpiNet, vpiScalarVal");
-         when vpiIntVal=>
+         when vpiIntVal =>
             dbgPut_Line ("vpi_put_value: vpiIntVal");
-         when vpiRealVal=>     dbgPut_Line("vpi_put_value: vpiRealVal");
-         when vpiStringVal=>   dbgPut_Line("vpi_put_value: vpiStringVal");
-         when vpiTimeVal=>     dbgPut_Line("vpi_put_value: vpiTimeVal");
-         when vpiVectorVal=>   dbgPut_Line("vpi_put_value: vpiVectorVal");
-         when vpiStrengthVal=> dbgPut_Line("vpi_put_value: vpiStrengthVal");
-         when others=>         dbgPut_Line("vpi_put_value: unknown mFormat");
+         when vpiRealVal =>
+            dbgPut_Line("vpi_put_value: vpiRealVal");
+         when vpiStringVal =>
+            dbgPut_Line("vpi_put_value: vpiStringVal");
+         when vpiTimeVal =>
+            dbgPut_Line("vpi_put_value: vpiTimeVal");
+         when vpiVectorVal =>
+            dbgPut_Line("vpi_put_value: vpiVectorVal");
+         when vpiStrengthVal =>
+            dbgPut_Line("vpi_put_value: vpiStrengthVal");
+         when others =>
+            dbgPut_Line("vpi_put_value: unknown mFormat");
       end case;
 
       -- Must return a scheduled event caused by vpi_put_value()
diff -urN ghdl-0.26/vhdl/grt/grt-vpi.ads ghdl-0.26dev/vhdl/grt/grt-vpi.ads
--- ghdl-0.26/vhdl/grt/grt-vpi.ads	2005-09-23 00:18:14.000000000 +0200
+++ ghdl-0.26dev/vhdl/grt/grt-vpi.ads	2008-05-16 11:27:50.000000000 +0200
@@ -79,10 +79,10 @@
    --   double real;
    -- } s_vpi_time, *p_vpi_time;
    type s_vpi_time is record
-      mType : integer;
-      mHigh : integer; -- this should be unsigned
-      mLow :  integer; -- this should be unsigned
-      mReal : float;   -- this should be double
+      mType : Integer;
+      mHigh : Integer; -- this should be unsigned
+      mLow :  Integer; -- this should be unsigned
+      mReal : Float;   -- this should be double
    end record;
    type p_vpi_time is access s_vpi_time;
 
diff -urN ghdl-0.26/vhdl/iirs_utils.adb ghdl-0.26dev/vhdl/iirs_utils.adb
--- ghdl-0.26/vhdl/iirs_utils.adb	2006-09-26 02:18:16.000000000 +0200
+++ ghdl-0.26dev/vhdl/iirs_utils.adb	2008-05-16 11:27:54.000000000 +0200
@@ -827,7 +827,9 @@
               | Iir_Kind_Function_Call =>
                return False;
             when Iir_Kind_Signal_Declaration
-              | Iir_Kind_Signal_Interface_Declaration =>
+              | Iir_Kind_Signal_Interface_Declaration
+              | Iir_Kind_Guard_Signal_Declaration
+              | Iir_Kinds_Signal_Attribute =>
                return True;
             when Iir_Kind_Object_Alias_Declaration =>
                Adecl := Get_Base_Name (Get_Name (Adecl));
diff -urN ghdl-0.26/vhdl/Makefile.in ghdl-0.26dev/vhdl/Makefile.in
--- ghdl-0.26/vhdl/Makefile.in	2007-04-08 18:46:39.000000000 +0200
+++ ghdl-0.26dev/vhdl/Makefile.in	2008-05-16 11:28:52.000000000 +0200
@@ -456,6 +456,10 @@
   GRT_EXTRA_LIB=-lm $(GRT_ELF_OPTS)
   ADAC=gnatgcc
 endif
+ifeq ($(filter-out i%86 darwin%,$(arch) $(osys)),)
+  GRT_TARGET_OBJS=i386.o linux.o times.o
+  GRT_EXTRA_LIB=-lm
+endif
 ifeq ($(filter-out sparc solaris%,$(arch) $(osys)),)
   GRT_TARGET_OBJS=sparc.o linux.o times.o
   GRT_EXTRA_LIB=-ldl -lm
@@ -471,9 +475,10 @@
 ifeq ($(filter-out i%86 mingw32,$(arch) $(osys)),)
   GRT_TARGET_OBJS=win32.o clock.o
 endif
-ifeq ($(filter-out i%86 cygwin,$(arch) $(osys)),)
-  GRT_TARGET_OBJS=win32.o clock.o
-endif
+# Doesn't work for unknown reasons.
+#ifeq ($(filter-out i%86 cygwin,$(arch) $(osys)),)
+#  GRT_TARGET_OBJS=win32.o clock.o
+#endif
 # Fall-back: use a generic implementation based on pthreads.
 ifndef GRT_TARGET_OBJS
   GRT_TARGET_OBJS=pthread.o times.o
@@ -541,6 +546,9 @@
 win32.o: $(GRTSRCDIR)/config/win32.c
 	$(CC) -c $(GRT_FLAGS) -o $@ $<
 
+win32thr.o: $(GRTSRCDIR)/config/win32thr.c
+	$(CC) -c $(GRT_FLAGS) -o $@ $<
+
 pthread.o: $(GRTSRCDIR)/config/pthread.c
 	$(CC) -c $(GRT_FLAGS) -o $@ $<
 
@@ -559,6 +567,12 @@
 grt-cthreads.o: $(GRTSRCDIR)/grt-cthreads.c
 	$(CC) -c $(GRT_FLAGS) -o $@ $<
 
+grt-disp-config:
+	@echo "target: $(target)"
+	@echo "targ: $(targ)"
+	@echo "arch: $(arch)"
+	@echo "osys: $(osys)"
+
 grt-files: run-bind.adb
 	sed -e "1,/-- *BEGIN/d" -e "/-- *END/,\$$d" \
 	  -e "s/   --   //" < $< > $@
diff -urN ghdl-0.26/vhdl/parse.adb ghdl-0.26dev/vhdl/parse.adb
--- ghdl-0.26/vhdl/parse.adb	2005-12-30 14:38:27.000000000 +0100
+++ ghdl-0.26dev/vhdl/parse.adb	2008-05-16 11:27:54.000000000 +0200
@@ -288,7 +288,7 @@
             end if;
             Scan.Scan;
             if Current_Token = Tok_Box then
-               Unexpected ("<> not allowed here");
+               Unexpected ("range expression expected");
                Scan.Scan;
                return Null_Iir;
             end if;
@@ -385,6 +385,12 @@
       end if;
       Scan.Scan;
 
+      if Current_Token = Tok_Box then
+         Error_Msg_Parse ("range constraint required");
+         Scan.Scan;
+         return Null_Iir;
+      end if;
+
       return Parse_Range;
    end Parse_Range_Constraint;
 
@@ -407,6 +413,9 @@
          when Tok_Range =>
             --  FIXME: create a subtype indication.
             Rng := Parse_Range_Constraint;
+            if Rng = Null_Iir then
+               return Left;
+            end if;
             Set_Type (Rng, Left);
             return Rng;
          when others =>
diff -urN ghdl-0.26/vhdl/sem_expr.adb ghdl-0.26dev/vhdl/sem_expr.adb
--- ghdl-0.26/vhdl/sem_expr.adb	2007-03-24 08:37:15.000000000 +0100
+++ ghdl-0.26dev/vhdl/sem_expr.adb	2008-05-16 11:27:54.000000000 +0200
@@ -168,7 +168,8 @@
            | Iir_Kind_Library_Clause
            | Iir_Kind_Component_Declaration
            | Iir_Kinds_Procedure_Declaration
-           | Iir_Kind_Range_Array_Attribute =>
+           | Iir_Kind_Range_Array_Attribute
+           | Iir_Kind_Element_Declaration =>
             Error_Msg_Sem (Disp_Node (Expr)
                            & " not allowed in an expression", Loc);
             return Null_Iir;
@@ -2739,7 +2740,8 @@
 
          when Iir_Kind_String_Literal
            | Iir_Kind_Bit_String_Literal =>
-            Len := Sem_String_Literal (Aggr, Get_Element_Subtype (A_Type));
+            Len := Sem_String_Literal
+              (Aggr, Get_Base_Type (Get_Element_Subtype (A_Type)));
             Assoc_Chain := Null_Iir;
             Info.Min_Length := Integer'Max (Info.Min_Length, Len);
             Is_Positional := True;
diff -urN ghdl-0.26/vhdl/sem_names.adb ghdl-0.26dev/vhdl/sem_names.adb
--- ghdl-0.26/vhdl/sem_names.adb	2007-03-28 00:36:16.000000000 +0200
+++ ghdl-0.26dev/vhdl/sem_names.adb	2008-05-16 11:27:54.000000000 +0200
@@ -1573,7 +1573,8 @@
            | Iir_Kind_Selected_Element
            | Iir_Kind_Dereference
            | Iir_Kind_Implicit_Dereference
-           | Iir_Kind_Attribute_Value =>
+           | Iir_Kind_Attribute_Value
+           | Iir_Kind_Function_Call =>
             if Get_Kind (Get_Type (Prefix))
               = Iir_Kind_Protected_Type_Declaration
             then
diff -urN ghdl-0.26/vhdl/translation.adb ghdl-0.26dev/vhdl/translation.adb
--- ghdl-0.26/vhdl/translation.adb	2007-03-14 00:12:38.000000000 +0100
+++ ghdl-0.26dev/vhdl/translation.adb	2008-05-16 11:27:50.000000000 +0200
@@ -11047,6 +11047,10 @@
          Push_Identifier_Prefix
            (Mark3, Get_Identifier (Get_Base_Name (Formal)));
 
+         if Is_Anonymous_Type_Definition (In_Type) then
+            In_Type := Get_Base_Type (In_Type);
+         end if;
+
          Out_Info := Get_Info (Out_Type);
          In_Info := Get_Info (In_Type);
 
@@ -11794,15 +11798,16 @@
       begin
          Obj := Sem_Names.Name_To_Object (Expr);
          if Obj /= Null_Iir then
-            case Get_Kind (Get_Base_Name (Obj)) is
-               when Iir_Kind_Signal_Declaration
-                 | Iir_Kind_Signal_Interface_Declaration
-                 | Iir_Kind_Guard_Signal_Declaration
-                 | Iir_Kinds_Signal_Attribute =>
-                  return True;
-               when others =>
-                  return False;
-            end case;
+            return Is_Signal_Object (Obj);
+--              case Get_Kind (Get_Base_Name (Obj)) is
+--                 when Iir_Kind_Signal_Declaration
+--                   | Iir_Kind_Signal_Interface_Declaration
+--                   | Iir_Kind_Guard_Signal_Declaration
+--                   | Iir_Kinds_Signal_Attribute =>
+--                    return True;
+--                 when others =>
+--                    return False;
+--              end case;
          else
             return False;
          end if;
@@ -26794,9 +26799,9 @@
                     (Mark, Name_Table.Get_Identifier ("DEFAULT_CONFIG"));
                   Chap1.Translate_Configuration_Declaration (El);
                   Pop_Identifier_Prefix (Mark);
-                  Pop_Identifier_Prefix (Mark_Entity);
-                  Pop_Identifier_Prefix (Mark_Sep);
                   Pop_Identifier_Prefix (Mark_Arch);
+                  Pop_Identifier_Prefix (Mark_Sep);
+                  Pop_Identifier_Prefix (Mark_Entity);
                end;
             else
                Chap1.Translate_Configuration_Declaration (El);
@@ -28308,6 +28313,7 @@
          Assoc : O_Assoc_List;
          Instance : O_Dnode;
          Arch_Instance : O_Dnode;
+         Mark : Id_Mark_Type;
       begin
          Arch_Info := Get_Info (Arch);
          Entity_Info := Get_Info (Entity);
@@ -28376,6 +28382,7 @@
 
          --  init instance
          Push_Scope (Entity_Info.Block_Decls_Type, Instance);
+         Push_Identifier_Prefix (Mark, "");
          Chap1.Translate_Entity_Init (Entity);
 
          --  elab instance
@@ -28390,6 +28397,7 @@
          New_Association (Assoc, New_Obj_Value (Arch_Instance));
          New_Procedure_Call (Assoc);
 
+         Pop_Identifier_Prefix (Mark);
          Pop_Scope (Entity_Info.Block_Decls_Type);
          Finish_Subprogram_Body;
 
diff -urN ghdl-0.26/vhdl/types.ads ghdl-0.26dev/vhdl/types.ads
--- ghdl-0.26/vhdl/types.ads	2005-09-22 23:23:20.000000000 +0200
+++ ghdl-0.26dev/vhdl/types.ads	2008-05-16 11:27:54.000000000 +0200
@@ -121,4 +121,9 @@
    --  Self-explaining: raised when an internal error (such as consistency)
    --  is detected.
    Internal_Error: exception;
+
+   --  In some case, a low level subprogram can't handle error
+   --  (e.g eval_pos).  In this case it is easier to raise an exception and
+   --  let upper level subprograms handle the case.
+   Node_Error : exception;
 end Types;
diff -urN ghdl-0.26/vhdl/version.ads ghdl-0.26dev/vhdl/version.ads
--- ghdl-0.26/vhdl/version.ads	2007-04-08 18:43:04.000000000 +0200
+++ ghdl-0.26dev/vhdl/version.ads	2008-05-16 11:27:54.000000000 +0200
@@ -1,5 +1,5 @@
 package Version is
    Ghdl_Release : constant String :=
-      "GHDL 0.26 (20070408) [Sokcho edition]";
+      "GHDL 0.26dev (20070408) [Sokcho edition]";
    Ghdl_Ver : constant String := "0.26";
 end Version;
