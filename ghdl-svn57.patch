diff -urN ghdl-0.23/vhdl/canon.adb ghdl-0.23dev/vhdl/canon.adb
--- ghdl-0.23/vhdl/canon.adb	2005-10-26 12:22:18.000000000 +0200
+++ ghdl-0.23dev/vhdl/canon.adb	2006-06-20 13:58:05.000000000 +0200
@@ -43,11 +43,11 @@
    --    if INTERFACE_LIST is null then returns null.
    --    if INTERFACE_LIST is not null, a default list is created.
    function Canon_Association_Chain
-     (Interface_Chain: Iir; Association_Chain: Iir)
+     (Interface_Chain: Iir; Association_Chain: Iir; Loc : Iir)
      return Iir;
 
    function Canon_Association_Chain_And_Actuals
-     (Interface_Chain : Iir; Association_Chain : Iir)
+     (Interface_Chain : Iir; Association_Chain : Iir; Loc : Iir)
      return Iir;
 
    --  Canonicalize block configuration CONF.
@@ -391,7 +391,8 @@
                if Get_Kind (Imp) /= Iir_Kind_Implicit_Function_Declaration then
                   Assoc_Chain := Canon_Association_Chain_And_Actuals
                     (Get_Interface_Declaration_Chain (Imp),
-                     Get_Parameter_Association_Chain (Expr));
+                     Get_Parameter_Association_Chain (Expr),
+                     Expr);
                   Set_Parameter_Association_Chain (Expr, Assoc_Chain);
                else
                   -- FIXME:
@@ -511,7 +512,7 @@
    -- reorder associations by name,
    -- create omitted association,
    function Canon_Association_Chain
-     (Interface_Chain : Iir; Association_Chain : Iir)
+     (Interface_Chain : Iir; Association_Chain : Iir; Loc : Iir)
      return Iir
    is
       -- The canon list of association.
@@ -586,8 +587,7 @@
          -- No association, use default expr.
          Assoc_El := Create_Iir (Iir_Kind_Association_Element_Open);
          Set_Artificial_Flag (Assoc_El, True);
-         --  FIXME: association_list can be null_iir_list!
-         --Location_Copy (Assoc_El, Association_List);
+         Location_Copy (Assoc_El, Loc);
          Set_Formal (Assoc_El, Inter);
          Sub_Chain_Append (N_Chain, Last, Assoc_El);
 
@@ -615,12 +615,13 @@
    end Canon_Association_Chain_Actuals;
 
    function Canon_Association_Chain_And_Actuals
-     (Interface_Chain : Iir; Association_Chain : Iir)
+     (Interface_Chain : Iir; Association_Chain : Iir; Loc : Iir)
      return Iir
    is
       Res : Iir;
    begin
-      Res := Canon_Association_Chain (Interface_Chain, Association_Chain);
+      Res := Canon_Association_Chain
+        (Interface_Chain, Association_Chain, Loc);
       Canon_Association_Chain_Actuals (Res);
       return Res;
    end Canon_Association_Chain_And_Actuals;
@@ -634,7 +635,7 @@
       Imp := Get_Implementation (Call);
       Inter_Chain := Get_Interface_Declaration_Chain (Imp);
       Assoc_Chain := Get_Parameter_Association_Chain (Call);
-      Assoc_Chain := Canon_Association_Chain (Inter_Chain, Assoc_Chain);
+      Assoc_Chain := Canon_Association_Chain (Inter_Chain, Assoc_Chain, Call);
       Set_Parameter_Association_Chain (Call, Assoc_Chain);
       return Assoc_Chain;
    end Canon_Subprogram_Call;
@@ -714,7 +715,8 @@
    begin
       Assoc_Chain := Canon_Association_Chain_And_Actuals
         (Get_Interface_Declaration_Chain (Get_Implementation (Call)),
-         Get_Parameter_Association_Chain (Call));
+         Get_Parameter_Association_Chain (Call),
+         Call);
       Set_Parameter_Association_Chain (Call, Assoc_Chain);
    end Canon_Procedure_Call;
 
@@ -1008,7 +1010,8 @@
       Set_Procedure_Call (Call_Stmt, Call);
       Assoc_Chain := Canon_Association_Chain
         (Get_Interface_Declaration_Chain (Imp),
-         Get_Parameter_Association_Chain (Call));
+         Get_Parameter_Association_Chain (Call),
+         Call);
       Set_Parameter_Association_Chain (Call, Assoc_Chain);
       Driver_List := Null_Iir_List;
       Assoc := Assoc_Chain;
@@ -1319,12 +1322,14 @@
                   Inst := Get_Entity_From_Entity_Aspect (Inst);
                   Assoc_Chain := Canon_Association_Chain
                     (Get_Generic_Chain (Inst),
-                     Get_Generic_Map_Aspect_Chain (El));
+                     Get_Generic_Map_Aspect_Chain (El),
+                     El);
                   Set_Generic_Map_Aspect_Chain (El, Assoc_Chain);
 
                   Assoc_Chain := Canon_Association_Chain
                     (Get_Port_Chain (Inst),
-                     Get_Port_Map_Aspect_Chain (El));
+                     Get_Port_Map_Aspect_Chain (El),
+                     El);
                   Set_Port_Map_Aspect_Chain (El, Assoc_Chain);
                end;
 
@@ -1350,7 +1355,7 @@
                      Chain := Get_Generic_Map_Aspect_Chain (Header);
                      if Chain /= Null_Iir then
                         Chain := Canon_Association_Chain
-                          (Get_Generic_Chain (Header), Chain);
+                          (Get_Generic_Chain (Header), Chain, Chain);
                      else
                         Chain := Canon_Default_Association_Chain
                           (Get_Generic_Chain (Header));
@@ -1361,7 +1366,7 @@
                      Chain := Get_Port_Map_Aspect_Chain (Header);
                      if Chain /= Null_Iir then
                         Chain := Canon_Association_Chain
-                          (Get_Port_Chain (Header), Chain);
+                          (Get_Port_Chain (Header), Chain, Chain);
                      else
                         Chain := Canon_Default_Association_Chain
                           (Get_Port_Chain (Header));
@@ -1485,7 +1490,7 @@
                Map_Chain := Get_Default_Generic_Map_Aspect_Chain (Bind);
             else
                Map_Chain := Canon_Association_Chain
-                 (Get_Generic_Chain (Entity), Map_Chain);
+                 (Get_Generic_Chain (Entity), Map_Chain, Map_Chain);
             end if;
             Set_Generic_Map_Aspect_Chain (Bind, Map_Chain);
 
@@ -1494,7 +1499,7 @@
                Map_Chain := Get_Default_Port_Map_Aspect_Chain (Bind);
             else
                Map_Chain := Canon_Association_Chain
-                 (Get_Port_Chain (Entity), Map_Chain);
+                 (Get_Port_Chain (Entity), Map_Chain, Map_Chain);
             end if;
             Set_Port_Map_Aspect_Chain (Bind, Map_Chain);
 
diff -urN ghdl-0.23/vhdl/errorout.adb ghdl-0.23dev/vhdl/errorout.adb
--- ghdl-0.23/vhdl/errorout.adb	2006-03-12 04:36:48.000000000 +0100
+++ ghdl-0.23dev/vhdl/errorout.adb	2006-06-20 13:58:05.000000000 +0200
@@ -980,9 +980,12 @@
       Decl := Get_Type_Declarator (Def);
       if Decl /= Null_Iir then
          return Image_Identifier (Decl);
-      else
-         Decl := Get_Type_Declarator (Get_Base_Type (Def));
+      end if;
+      Decl := Get_Type_Declarator (Get_Base_Type (Def));
+      if Decl /= Null_Iir then
          return "a subtype of " & Image_Identifier (Decl);
+      else
+         return "an unknown type";
       end if;
    end Disp_Type_Name;
 
diff -urN ghdl-0.23/vhdl/flags.ads ghdl-0.23dev/vhdl/flags.ads
--- ghdl-0.23/vhdl/flags.ads	2005-10-26 11:56:36.000000000 +0200
+++ ghdl-0.23dev/vhdl/flags.ads	2006-06-20 13:58:05.000000000 +0200
@@ -164,7 +164,7 @@
    --  --warn-delayed-checks
    --  Emit warnings about delayed checks (checks performed at elaboration
    --   time).
-   Warn_Delayed_Checks : Boolean := True;
+   Warn_Delayed_Checks : Boolean := False;
 
    --  --warn-body
    --  Emit a warning when a package body is not required but is analyzed.
diff -urN ghdl-0.23/vhdl/ghdl.texi ghdl-0.23dev/vhdl/ghdl.texi
--- ghdl-0.23/vhdl/ghdl.texi	2006-03-16 05:10:09.000000000 +0100
+++ ghdl-0.23dev/vhdl/ghdl.texi	2006-06-20 13:57:57.000000000 +0200
@@ -376,11 +376,12 @@
 
 Let's see how to analyze and run a bigger design, such as the DLX model
 suite written by Peter Ashenden which is distributed under the terms of the
-GNU General Public License.
+GNU General Public License.  A copy is kept on
+@indicateurl{http://ghdl.free.fr/dlx.tar.gz}
 
 First, untar the sources:
 @smallexample
-$ tar zxvf dlx.tar.Z
+$ tar zxvf dlx.tar.gz
 @end smallexample
 
 In order not to pollute the sources with the library, it is a good idea
@@ -946,10 +947,14 @@
 
 @item --warn-delayed-checks
 @cindex @option{--warn-delayed-checks} switch
-Warns for checks that cannot be done during analysis time and are postponed to
-elaboration time.  These checks are checks for no wait statement in a procedure
-called in a sensitized process.  If the body of the procedure is not known
-at analysis time, the check will be performed during elaboration.
+Warns for checks that cannot be done during analysis time and are
+postponed to elaboration time.  This is because not all procedure
+bodies are available during analysis (either because a package body
+has not yet been analysed or because @code{GHDL} doesn't read not required
+package bodies).
+
+These are checks for no wait statement in a procedure called in a
+sensitized process and checks for pure rules of a function.
 
 @item --warn-body
 @cindex @option{--warn-body} switch
diff -urN ghdl-0.23/vhdl/grt/grt-avhpi.adb ghdl-0.23dev/vhdl/grt/grt-avhpi.adb
--- ghdl-0.23/vhdl/grt/grt-avhpi.adb	2005-09-23 00:02:29.000000000 +0200
+++ ghdl-0.23dev/vhdl/grt/grt-avhpi.adb	2006-06-20 13:58:01.000000000 +0200
@@ -329,7 +329,8 @@
                end if;
             end;
          when Ghdl_Rtik_Type_B2
-           | Ghdl_Rtik_Type_E8 =>
+           | Ghdl_Rtik_Type_E8
+	   | Ghdl_Rtik_Type_E32 =>
             Res := (Kind => VhpiEnumTypeDeclK,
                     Ctxt => Ctxt,
                     Atype => Rti);
@@ -387,6 +388,7 @@
                  | Ghdl_Rtik_Subtype_Array
                  | Ghdl_Rtik_Subtype_Array_Ptr
                  | Ghdl_Rtik_Type_E8
+                 | Ghdl_Rtik_Type_E32
                  | Ghdl_Rtik_Type_B2 =>
                   Rti_To_Handle (Ch, Iterator.Ctxt, Res);
                   if Res.Kind /= VhpiUndefined then
@@ -581,6 +583,9 @@
 --                         when Ghdl_Rtik_Type_E8 =>
 --                            Disp_Enum_Value
 --                              (Stream, Rti, Ghdl_Index_Type (Vptr.E8));
+--                         when Ghdl_Rtik_Type_E32 =>
+--                            Disp_Enum_Value
+--                              (Stream, Rti, Ghdl_Index_Type (Vptr.E32));
 --                         when Ghdl_Rtik_Type_B2 =>
 --                            Disp_Enum_Value
 --                              (Stream, Rti,
diff -urN ghdl-0.23/vhdl/grt/grt-disp_rti.adb ghdl-0.23dev/vhdl/grt/grt-disp_rti.adb
--- ghdl-0.23/vhdl/grt/grt-disp_rti.adb	2005-12-11 18:23:20.000000000 +0100
+++ ghdl-0.23dev/vhdl/grt/grt-disp_rti.adb	2006-06-20 13:58:01.000000000 +0200
@@ -73,6 +73,11 @@
             if not Is_Sig then
                Update (8);
             end if;
+         when Ghdl_Rtik_Type_E32 =>
+            Disp_Enum_Value (Stream, Rti, Ghdl_Index_Type (Vptr.E32));
+            if not Is_Sig then
+               Update (32);
+            end if;
          when Ghdl_Rtik_Type_B2 =>
             Disp_Enum_Value (Stream, Rti,
                              Ghdl_Index_Type (Ghdl_B2'Pos (Vptr.B2)));
@@ -201,6 +206,7 @@
                Obj, Is_Sig);
          when Ghdl_Rtik_Type_I32
            | Ghdl_Rtik_Type_E8
+           | Ghdl_Rtik_Type_E32
            | Ghdl_Rtik_Type_B2 =>
             Disp_Scalar_Value (Stream, Rti, Obj, Is_Sig);
          when Ghdl_Rtik_Type_Array =>
@@ -310,6 +316,8 @@
             Put ("ghdl_rtik_type_b2");
          when Ghdl_Rtik_Type_E8 =>
             Put ("ghdl_rtik_type_e8");
+         when Ghdl_Rtik_Type_E32 =>
+            Put ("ghdl_rtik_type_e32");
          when Ghdl_Rtik_Type_P64 =>
             Put ("ghdl_rtik_type_p64");
          when Ghdl_Rtik_Type_I32 =>
diff -urN ghdl-0.23/vhdl/grt/grt-files.adb ghdl-0.23dev/vhdl/grt/grt-files.adb
--- ghdl-0.23/vhdl/grt/grt-files.adb	2005-12-05 20:48:13.000000000 +0100
+++ ghdl-0.23dev/vhdl/grt/grt-files.adb	2006-06-20 13:58:01.000000000 +0200
@@ -153,8 +153,8 @@
       end if;
 
       --  Copy file name and convert it to a C string (NUL terminated).
-      for I in 0 .. Str.Bounds.Dim_1.Length - 1 loop
-         Name (1 + Natural (I)) := Str.Base (I);
+      for I in 1 .. Str.Bounds.Dim_1.Length loop
+         Name (Natural (I)) := Str.Base (I - 1);
       end loop;
       Name (Name'Last) := NUL;
 
diff -urN ghdl-0.23/vhdl/grt/grt-images.adb ghdl-0.23dev/vhdl/grt/grt-images.adb
--- ghdl-0.23/vhdl/grt/grt-images.adb	2005-12-12 21:26:46.000000000 +0100
+++ ghdl-0.23dev/vhdl/grt/grt-images.adb	2006-06-20 13:58:01.000000000 +0200
@@ -68,6 +68,13 @@
       Return_Enum (Res, Rti, Ghdl_E8'Pos (Val));
    end Ghdl_Image_E8;
 
+   procedure Ghdl_Image_E32
+     (Res : Std_String_Ptr; Val : Ghdl_E32; Rti : Ghdl_Rti_Access)
+   is
+   begin
+      Return_Enum (Res, Rti, Ghdl_E32'Pos (Val));
+   end Ghdl_Image_E32;
+
    procedure Ghdl_Image_I32 (Res : Std_String_Ptr; Val : Ghdl_I32)
    is
       Str : String (1 .. 11);
diff -urN ghdl-0.23/vhdl/grt/grt-images.ads ghdl-0.23dev/vhdl/grt/grt-images.ads
--- ghdl-0.23/vhdl/grt/grt-images.ads	2005-09-23 00:27:44.000000000 +0200
+++ ghdl-0.23dev/vhdl/grt/grt-images.ads	2006-06-20 13:58:01.000000000 +0200
@@ -23,6 +23,8 @@
      (Res : Std_String_Ptr; Val : Ghdl_B2; Rti : Ghdl_Rti_Access);
    procedure Ghdl_Image_E8
      (Res : Std_String_Ptr; Val : Ghdl_E8; Rti : Ghdl_Rti_Access);
+   procedure Ghdl_Image_E32
+     (Res : Std_String_Ptr; Val : Ghdl_E32; Rti : Ghdl_Rti_Access);
    procedure Ghdl_Image_I32 (Res : Std_String_Ptr; Val : Ghdl_I32);
    procedure Ghdl_Image_F64 (Res : Std_String_Ptr; Val : Ghdl_F64);
    procedure Ghdl_Image_P64
@@ -32,6 +34,7 @@
 private
    pragma Export (C, Ghdl_Image_B2, "__ghdl_image_b2");
    pragma Export (C, Ghdl_Image_E8, "__ghdl_image_e8");
+   pragma Export (C, Ghdl_Image_E32, "__ghdl_image_e32");
    pragma Export (C, Ghdl_Image_I32, "__ghdl_image_i32");
    pragma Export (C, Ghdl_Image_F64, "__ghdl_image_f64");
    pragma Export (C, Ghdl_Image_P64, "__ghdl_image_p64");
diff -urN ghdl-0.23/vhdl/grt/grt-rtis_addr.adb ghdl-0.23dev/vhdl/grt/grt-rtis_addr.adb
--- ghdl-0.23/vhdl/grt/grt-rtis_addr.adb	2005-09-23 00:30:47.000000000 +0200
+++ ghdl-0.23dev/vhdl/grt/grt-rtis_addr.adb	2006-06-20 13:58:01.000000000 +0200
@@ -231,6 +231,10 @@
                   Align (Ghdl_Range_E8'Alignment);
                   Res (I) := To_Ghdl_Range_Ptr (Bounds);
                   Update (Ghdl_Range_E8'Size);
+               when Ghdl_Rtik_Type_E32 =>
+                  Align (Ghdl_Range_E32'Alignment);
+                  Res (I) := To_Ghdl_Range_Ptr (Bounds);
+                  Update (Ghdl_Range_E32'Size);
                when others =>
                   --  Bounds are not known anymore.
                   Bounds := Null_Address;
@@ -249,6 +253,7 @@
             return To_Ghdl_Rti_Access
               (To_Ghdl_Rtin_Subtype_Array_Acc (Atype).Basetype);
          when Ghdl_Rtik_Type_E8
+	   | Ghdl_Rtik_Type_E32
            | Ghdl_Rtik_Type_B2 =>
             return Atype;
          when others =>
diff -urN ghdl-0.23/vhdl/grt/grt-rtis_utils.adb ghdl-0.23dev/vhdl/grt/grt-rtis_utils.adb
--- ghdl-0.23/vhdl/grt/grt-rtis_utils.adb	2005-12-12 03:06:57.000000000 +0100
+++ ghdl-0.23dev/vhdl/grt/grt-rtis_utils.adb	2006-06-20 13:58:01.000000000 +0200
@@ -198,6 +198,8 @@
                   Update (32);
                when Ghdl_Rtik_Type_E8 =>
                   Update (8);
+               when Ghdl_Rtik_Type_E32 =>
+                  Update (32);
                when Ghdl_Rtik_Type_B2 =>
                   Update (8);
                when Ghdl_Rtik_Type_F64 =>
@@ -231,6 +233,13 @@
                   when Dir_Downto =>
                      Val.E8 := Rng.E8.Left - Ghdl_E8 (Pos);
                end case;
+            when Ghdl_Rtik_Type_E32 =>
+               case Rng.E32.Dir is
+                  when Dir_To =>
+                     Val.E32 := Rng.E32.Left + Ghdl_E32 (Pos);
+                  when Dir_Downto =>
+                     Val.E32 := Rng.E32.Left - Ghdl_E32 (Pos);
+               end case;
             when Ghdl_Rtik_Type_B2 =>
                case Pos is
                   when 0 =>
@@ -265,6 +274,8 @@
                end;
             when Ghdl_Rtik_Type_E8 =>
                Get_Enum_Value (Vstr, Rti, Ghdl_Index_Type (V.E8));
+            when Ghdl_Rtik_Type_E32 =>
+               Get_Enum_Value (Vstr, Rti, Ghdl_Index_Type (V.E32));
             when Ghdl_Rtik_Type_B2 =>
                Get_Enum_Value (Vstr, Rti, Ghdl_B2'Pos (V.B2));
             when others =>
@@ -348,6 +359,7 @@
                Handle_Scalar (To_Ghdl_Rtin_Subtype_Scalar_Acc (Rti).Basetype);
             when Ghdl_Rtik_Type_I32
               | Ghdl_Rtik_Type_E8
+              | Ghdl_Rtik_Type_E32
               | Ghdl_Rtik_Type_B2 =>
                Handle_Scalar (Rti);
             when Ghdl_Rtik_Type_Array =>
@@ -430,6 +442,8 @@
             end;
          when Ghdl_Rtik_Type_E8 =>
             Get_Enum_Value (Str, Type_Rti, Ghdl_Index_Type (Value.E8));
+         when Ghdl_Rtik_Type_E32 =>
+            Get_Enum_Value (Str, Type_Rti, Ghdl_Index_Type (Value.E32));
          when Ghdl_Rtik_Type_B2 =>
             Get_Enum_Value
               (Str, Type_Rti, Ghdl_Index_Type (Ghdl_B2'Pos (Value.B2)));
@@ -520,6 +534,8 @@
             end;
          when Ghdl_Rtik_Type_E8 =>
             Get_Enum_Value (Rstr, Type_Rti, Ghdl_Index_Type (Value.E8));
+         when Ghdl_Rtik_Type_E32 =>
+            Get_Enum_Value (Rstr, Type_Rti, Ghdl_Index_Type (Value.E32));
          when Ghdl_Rtik_Type_B2 =>
             Get_Enum_Value
               (Rstr, Type_Rti, Ghdl_Index_Type (Ghdl_B2'Pos (Value.B2)));
diff -urN ghdl-0.23/vhdl/grt/grt-signals.adb ghdl-0.23dev/vhdl/grt/grt-signals.adb
--- ghdl-0.23/vhdl/grt/grt-signals.adb	2005-12-20 14:18:39.000000000 +0100
+++ ghdl-0.23dev/vhdl/grt/grt-signals.adb	2006-06-20 13:58:01.000000000 +0200
@@ -802,6 +802,77 @@
         (Sign, Value_Union'(Mode => Mode_E8, E8 => Val), After);
    end Ghdl_Signal_Next_Assign_E8;
 
+   function Ghdl_Create_Signal_E32
+     (Init_Val : Ghdl_E32;
+      Resolv_Func : System.Address;
+      Resolv_Inst : System.Address)
+     return Ghdl_Signal_Ptr
+   is
+   begin
+      return Create_Signal
+        (Mode_E32, Value_Union'(Mode => Mode_E32, E32 => Init_Val),
+         Get_Current_Mode_Signal,
+         Resolv_Func, Resolv_Inst);
+   end Ghdl_Create_Signal_E32;
+
+   procedure Ghdl_Signal_Init_E32 (Sig : Ghdl_Signal_Ptr; Init_Val : Ghdl_E32)
+   is
+   begin
+      Ghdl_Signal_Init (Sig, Value_Union'(Mode => Mode_E32, E32 => Init_Val));
+   end Ghdl_Signal_Init_E32;
+
+   procedure Ghdl_Signal_Associate_E32 (Sig : Ghdl_Signal_Ptr; Val : Ghdl_E32)
+   is
+   begin
+      Ghdl_Signal_Associate (Sig, Value_Union'(Mode => Mode_E32, E32 => Val));
+   end Ghdl_Signal_Associate_E32;
+
+   procedure Ghdl_Signal_Simple_Assign_E32 (Sign : Ghdl_Signal_Ptr;
+                                            Val : Ghdl_E32)
+   is
+      Trans : Transaction_Acc;
+   begin
+      if not Sign.Flags.Has_Active
+        and then Sign.Net = Net_One_Driver
+        and then Val = Sign.Value.E32
+        and then Sign.S.Drivers (0).First_Trans.Next = null
+      then
+         return;
+      end if;
+
+      Trans := new Transaction'
+        (Kind => Trans_Value,
+         Time => 0,
+         Next => null,
+         Val => Value_Union'(Mode => Mode_E32, E32 => Val));
+
+      Ghdl_Signal_Start_Assign (Sign, 0, Trans, 0);
+   end Ghdl_Signal_Simple_Assign_E32;
+
+   procedure Ghdl_Signal_Start_Assign_E32 (Sign : Ghdl_Signal_Ptr;
+                                           Rej : Std_Time;
+                                           Val : Ghdl_E32;
+                                           After : Std_Time)
+   is
+      Trans : Transaction_Acc;
+   begin
+      Trans := new Transaction'
+        (Kind => Trans_Value,
+         Time => 0,
+         Next => null,
+         Val => Value_Union'(Mode => Mode_E32, E32 => Val));
+      Ghdl_Signal_Start_Assign (Sign, Rej, Trans, After);
+   end Ghdl_Signal_Start_Assign_E32;
+
+   procedure Ghdl_Signal_Next_Assign_E32 (Sign : Ghdl_Signal_Ptr;
+                                          Val : Ghdl_E32;
+                                          After : Std_Time)
+   is
+   begin
+      Ghdl_Signal_Next_Assign
+        (Sign, Value_Union'(Mode => Mode_E32, E32 => Val), After);
+   end Ghdl_Signal_Next_Assign_E32;
+
    function Ghdl_Create_Signal_I32
      (Init_Val : Ghdl_I32;
       Resolv_Func : System.Address;
@@ -1358,6 +1429,19 @@
       end if;
    end Ghdl_Signal_Driving_Value_E8;
 
+   function Ghdl_Signal_Driving_Value_E32 (Sig : Ghdl_Signal_Ptr)
+                                         return Ghdl_E32
+   is
+      Drv : Driver_Acc;
+   begin
+      Drv := Get_Driver (Sig);
+      if Drv = null or else Drv.First_Trans.Kind /= Trans_Value then
+         Error ("'driving_value: no active driver in process for signal");
+      else
+         return Drv.First_Trans.Val.E32;
+      end if;
+   end Ghdl_Signal_Driving_Value_E32;
+
    function Ghdl_Signal_Driving_Value_I32 (Sig : Ghdl_Signal_Ptr)
                                           return Ghdl_I32
    is
diff -urN ghdl-0.23/vhdl/grt/grt-signals.ads ghdl-0.23dev/vhdl/grt/grt-signals.ads
--- ghdl-0.23/vhdl/grt/grt-signals.ads	2005-09-23 00:22:44.000000000 +0200
+++ ghdl-0.23dev/vhdl/grt/grt-signals.ads	2006-06-20 13:58:01.000000000 +0200
@@ -453,6 +453,25 @@
    function Ghdl_Signal_Driving_Value_E8 (Sig : Ghdl_Signal_Ptr)
                                          return Ghdl_E8;
 
+   function Ghdl_Create_Signal_E32
+     (Init_Val : Ghdl_E32;
+      Resolv_Func : System.Address;
+      Resolv_Inst : System.Address)
+     return Ghdl_Signal_Ptr;
+   procedure Ghdl_Signal_Init_E32 (Sig : Ghdl_Signal_Ptr; Init_Val : Ghdl_E32);
+   procedure Ghdl_Signal_Associate_E32 (Sig : Ghdl_Signal_Ptr; Val : Ghdl_E32);
+   procedure Ghdl_Signal_Simple_Assign_E32 (Sign : Ghdl_Signal_Ptr;
+                                           Val : Ghdl_E32);
+   procedure Ghdl_Signal_Start_Assign_E32 (Sign : Ghdl_Signal_Ptr;
+                                          Rej : Std_Time;
+                                          Val : Ghdl_E32;
+                                          After : Std_Time);
+   procedure Ghdl_Signal_Next_Assign_E32 (Sign : Ghdl_Signal_Ptr;
+                                         Val : Ghdl_E32;
+                                         After : Std_Time);
+   function Ghdl_Signal_Driving_Value_E32 (Sig : Ghdl_Signal_Ptr)
+                                         return Ghdl_E32;
+
    function Ghdl_Create_Signal_I32
      (Init_Val : Ghdl_I32;
       Resolv_Func : System.Address;
@@ -634,6 +653,21 @@
    pragma Export (C, Ghdl_Signal_Driving_Value_E8,
                   "__ghdl_signal_driving_value_e8");
 
+   pragma Export (C, Ghdl_Create_Signal_E32,
+                  "__ghdl_create_signal_e32");
+   pragma Export (C, Ghdl_Signal_Init_E32,
+                  "__ghdl_signal_init_e32");
+   pragma Export (C, Ghdl_Signal_Associate_E32,
+                  "__ghdl_signal_associate_e32");
+   pragma Export (C, Ghdl_Signal_Simple_Assign_E32,
+                  "__ghdl_signal_simple_assign_e32");
+   pragma Export (C, Ghdl_Signal_Start_Assign_E32,
+                  "__ghdl_signal_start_assign_e32");
+   pragma Export (C, Ghdl_Signal_Next_Assign_E32,
+                  "__ghdl_signal_next_assign_e32");
+   pragma Export (C, Ghdl_Signal_Driving_Value_E32,
+                  "__ghdl_signal_driving_value_e32");
+
    pragma Export (C, Ghdl_Create_Signal_I32,
                   "__ghdl_create_signal_i32");
    pragma Export (C, Ghdl_Signal_Init_I32,
diff -urN ghdl-0.23/vhdl/ieee-std_logic_1164.adb ghdl-0.23dev/vhdl/ieee-std_logic_1164.adb
--- ghdl-0.23/vhdl/ieee-std_logic_1164.adb	2005-09-22 23:28:05.000000000 +0200
+++ ghdl-0.23dev/vhdl/ieee-std_logic_1164.adb	2006-06-20 13:58:05.000000000 +0200
@@ -18,6 +18,7 @@
 with Types; use Types;
 with Std_Names; use Std_Names;
 with Errorout; use Errorout;
+with Std_Package;
 
 package body Ieee.Std_Logic_1164 is
    function Skip_Implicit (Decl : Iir) return Iir
@@ -44,6 +45,15 @@
 
       Decl := Get_Declaration_Chain (Pkg);
 
+      --  Skip a potential copyright constant.
+      if Decl /= Null_Iir
+        and then Get_Kind (Decl) = Iir_Kind_Constant_Declaration
+        and then (Get_Base_Type (Get_Type (Decl))
+                  = Std_Package.String_Type_Definition)
+      then
+         Decl := Get_Chain (Decl);
+      end if;
+
       --  The first declaration should be type std_ulogic.
       if Decl = Null_Iir
         or else Get_Kind (Decl) /= Iir_Kind_Type_Declaration
diff -urN ghdl-0.23/vhdl/ieee-vital_timing.adb ghdl-0.23dev/vhdl/ieee-vital_timing.adb
--- ghdl-0.23/vhdl/ieee-vital_timing.adb	2005-09-22 23:28:15.000000000 +0200
+++ ghdl-0.23dev/vhdl/ieee-vital_timing.adb	2006-06-20 13:58:05.000000000 +0200
@@ -1248,7 +1248,7 @@
       end if;
 
       if Flags.Warn_Vital_Generic then
-         Warning_Vital ("generic is not a VITAL generic", Decl);
+         Warning_Vital (Disp_Node (Decl) & " is not a VITAL generic", Decl);
       end if;
    end Check_Entity_Generic_Declaration;
 
diff -urN ghdl-0.23/vhdl/ortho-lang.c ghdl-0.23dev/vhdl/ortho-lang.c
--- ghdl-0.23/vhdl/ortho-lang.c	2006-03-22 03:16:54.000000000 +0100
+++ ghdl-0.23dev/vhdl/ortho-lang.c	2006-06-20 13:58:03.000000000 +0200
@@ -23,6 +23,8 @@
 #include "tree-pass.h"
 #include "tree-dump.h"
 
+static tree type_for_size (unsigned int precision, int unsignedp);
+
 const int tree_identifier_size = sizeof (struct tree_identifier);
 
 struct binding_level GTY(())
@@ -250,13 +252,14 @@
   push_binding ();
 
   build_common_tree_nodes (0, 0);
+  size_type_node = type_for_size (GET_MODE_BITSIZE (Pmode), 1);
+  set_sizetype (size_type_node);
+  build_common_tree_nodes_2 (0);
+
   n = build_decl (TYPE_DECL, get_identifier ("int"), integer_type_node);
   push_decl (n);
   n = build_decl (TYPE_DECL, get_identifier ("char"), char_type_node);
   push_decl (n);
-  size_type_node = unsigned_type_node;
-  set_sizetype (unsigned_type_node);
-  build_common_tree_nodes_2 (0);
 
   /* Create alloca builtin.  */
   {
diff -urN ghdl-0.23/vhdl/sem.adb ghdl-0.23dev/vhdl/sem.adb
--- ghdl-0.23/vhdl/sem.adb	2005-10-27 21:37:00.000000000 +0200
+++ ghdl-0.23dev/vhdl/sem.adb	2006-06-20 13:58:05.000000000 +0200
@@ -1691,7 +1691,18 @@
       end case;
    end Sem_Subprogram_Body;
 
-   procedure Update_And_Check_Pure_Wait (Subprg : Iir)
+   --  Status of Update_And_Check_Pure_Wait.
+   type Update_Pure_Status is
+     (
+      --  The purity is computed and known.
+      Update_Pure_Done,
+      --  A missing body prevents from computing the purity.
+      Update_Pure_Missing,
+      --  Purity is unknown (recursion).
+      Update_Pure_Unknown
+     );
+   function Update_And_Check_Pure_Wait (Subprg : Iir)
+                                       return Update_Pure_Status
    is
       procedure Error_Wait (Caller : Iir; Callee : Iir) is
       begin
@@ -1715,20 +1726,11 @@
       --  Current purity depth of SUBPRG.
       Depth : Iir_Int32;
       Depth_Callee : Iir_Int32;
-      Has_Unknown : Boolean;
       Has_Pure_Errors : Boolean := False;
       Has_Wait_Errors : Boolean := False;
       Npos : Natural;
+      Res, Res1 : Update_Pure_Status;
    begin
-      --  If the subprogram has no callee list, there is nothing to do.
-      if Callees_List = Null_Iir_List then
-         return;
-      end if;
-
-      --  This subprogram is being considered.
-      --  To avoid infinite loop, suppress its callees list.
-      Set_Callees_List (Subprg, Null_Iir_List);
-
       case Get_Kind (Subprg) is
          when Iir_Kind_Function_Declaration =>
             Kind := K_Function;
@@ -1746,7 +1748,8 @@
             then
                --  No need to go further.
                Destroy_Iir_List (Callees_List);
-               return;
+               Set_Callees_List (Subprg, Null_Iir_List);
+               return Update_Pure_Done;
             end if;
             Subprg_Bod := Get_Subprogram_Body (Subprg);
             Subprg_Depth := Get_Subprogram_Depth (Subprg);
@@ -1754,23 +1757,42 @@
          when Iir_Kind_Sensitized_Process_Statement =>
             Kind := K_Process;
             Subprg_Bod := Null_Iir;
-            Subprg_Depth := 0;
+            Subprg_Depth := Iir_Depth_Top;
             Depth := Iir_Depth_Impure;
          when others =>
             Error_Kind ("update_and_check_pure_wait(1)", Subprg);
       end case;
 
+      --  If the subprogram has no callee list, there is nothing to do.
+      if Callees_List = Null_Iir_List then
+         --  There are two reasons why a callees_list is null:
+         --  * either because SUBPRG does not call any procedure
+         --    in this case, the status are already known and we should have
+         --    returned in the above case.
+         --  * or because of a recursion
+         --    in this case the status are still unknown here.
+         return Update_Pure_Unknown;
+      end if;
+
+      --  By default we don't know the status.
+      Res := Update_Pure_Unknown;
+
+      --  This subprogram is being considered.
+      --  To avoid infinite loop, suppress its callees list.
+      Set_Callees_List (Subprg, Null_Iir_List);
+
       --  First loop: check without recursion.
       --  Second loop: recurse if necessary.
-      Has_Unknown := False;
       for J in 0 .. 1 loop
          Npos := 0;
          for I in Natural loop
             Callee := Get_Nth_Element (Callees_List, I);
             exit when Callee = Null_Iir;
+
+            --  Only procedures should appear in the list:
+            --  Pure functions should not be in the list.
+            --  Impure functions must have directly set Purity_State.
             if Get_Kind (Callee) /= Iir_Kind_Procedure_Declaration then
-               --  Pure functions should not be in the list.
-               --  Impure functions must have directly set Purity_State.
                Error_Kind ("update_and_check_pure_wait(3)", Callee);
             end if;
 
@@ -1778,24 +1800,28 @@
             Callee_Bod := Get_Subprogram_Body (Callee);
             if Callee_Bod = Null_Iir then
                --  No body yet for the subprogram called.
-               --  Nothing can be extracted from it, postpone the checks.
-               Has_Unknown := True;
+               --  Nothing can be extracted from it, postpone the checks until
+               --  elaboration.
+               Res := Update_Pure_Missing;
             else
                --  Second loop: recurse if a state is not known.
                if J = 1 and then (Get_Purity_State (Callee) = Unknown
                                   or else Get_Wait_State (Callee) = Unknown)
                then
-                  Update_And_Check_Pure_Wait (Callee);
+                  Res1 := Update_And_Check_Pure_Wait (Callee);
+                  if Res1 = Update_Pure_Missing then
+                     Res := Update_Pure_Missing;
+                  end if;
                end if;
 
-
                --  Check purity only if the subprogram is not impure.
                if Depth /= Iir_Depth_Impure then
                   Depth_Callee := Get_Impure_Depth (Callee_Bod);
 
                   --  Check purity depth.
                   if Depth_Callee < Subprg_Depth then
-                     --  The call is an impure call.
+                     --  The call is an impure call because it calls an outer
+                     --   subprogram (or an impure subprogram).
                      --  FIXME: check the compare.
                      Depth_Callee := Iir_Depth_Impure;
                      if Kind = K_Function then
@@ -1854,6 +1880,7 @@
                   Set_Wait_State (Subprg, False);
                end if;
             end if;
+            Res := Update_Pure_Done;
             exit;
          else
             Set_Nbr_Elements (Callees_List, Npos);
@@ -1861,8 +1888,35 @@
       end loop;
 
       Set_Callees_List (Subprg, Callees_List);
+
+      return Res;
    end Update_And_Check_Pure_Wait;
 
+   function Root_Update_And_Check_Pure_Wait (Subprg : Iir) return Boolean
+   is
+      Res : Update_Pure_Status;
+   begin
+      Res := Update_And_Check_Pure_Wait (Subprg);
+      case Res is
+         when Update_Pure_Done =>
+            return True;
+         when Update_Pure_Missing =>
+            return False;
+         when Update_Pure_Unknown =>
+            --  The purity/wait is unknown, but all callee were walked.
+            --  This means there are recursive calls but without violations.
+            if Get_Kind (Subprg) = Iir_Kind_Procedure_Declaration then
+               if Get_Purity_State (Subprg) = Unknown then
+                  Set_Purity_State (Subprg, Maybe_Impure);
+               end if;
+               if Get_Wait_State (Subprg) = Unknown then
+                  Set_Wait_State (Subprg, False);
+               end if;
+            end if;
+            return True;
+      end case;
+   end Root_Update_And_Check_Pure_Wait;
+
    procedure Sem_Analysis_Checks_List (Unit : Iir_Design_Unit;
                                        Emit_Warnings : Boolean)
    is
@@ -1884,10 +1938,13 @@
          case Get_Kind (El) is
             when Iir_Kind_Function_Declaration =>
                --  FIXME: remove from list if fully tested ?
-               Update_And_Check_Pure_Wait (El);
-               Callees := Get_Callees_List (El);
-               if Callees /= Null_Iir_List then
+               if not Root_Update_And_Check_Pure_Wait (El) then
+                  Keep := True;
                   if Emit_Warnings then
+                     Callees := Get_Callees_List (El);
+                     if Callees = Null_Iir_List then
+                        raise Internal_Error;
+                     end if;
                      Warning_Msg_Sem
                        ("can't assert that all calls in " & Disp_Node (El)
                         & " are pure or have not wait; "
@@ -1900,17 +1957,15 @@
                        ("(first such call is to " & Disp_Node (Callee) & ")",
                         Callee);
                   end if;
-                  Keep := True;
                end if;
             when Iir_Kind_Sensitized_Process_Statement =>
-               Update_And_Check_Pure_Wait (El);
-               if Get_Callees_List (El) /= Null_Iir_List then
+               if not Root_Update_And_Check_Pure_Wait (El) then
+                  Keep := True;
                   if Emit_Warnings then
                      Warning_Msg_Sem
                        ("can't assert that " & Disp_Node (El)
                         & " has not wait; will be checked at elaboration", El);
                   end if;
-                  Keep := True;
                end if;
             when others =>
                Error_Kind ("sem_analysis_checks_list", El);
diff -urN ghdl-0.23/vhdl/sem_expr.adb ghdl-0.23dev/vhdl/sem_expr.adb
--- ghdl-0.23/vhdl/sem_expr.adb	2006-01-14 00:16:28.000000000 +0100
+++ ghdl-0.23dev/vhdl/sem_expr.adb	2006-06-20 13:58:05.000000000 +0200
@@ -3767,7 +3767,7 @@
 
       if Res /= Null_Iir and then Is_Overloaded (Res) then
          Error_Overload (Expr);
-         Disp_Overload_List (Get_Overload_List (Res), Expr);
+         Disp_Overload_List (Get_Overload_List (Get_Type (Res)), Expr);
          return Null_Iir;
       end if;
       return Res;
diff -urN ghdl-0.23/vhdl/std_package.adb ghdl-0.23dev/vhdl/std_package.adb
--- ghdl-0.23/vhdl/std_package.adb	2005-10-26 12:03:20.000000000 +0200
+++ ghdl-0.23dev/vhdl/std_package.adb	2006-06-20 13:58:05.000000000 +0200
@@ -46,6 +46,15 @@
       return Res;
    end Create_Std_Iir;
 
+   function Create_Std_Decl (Kind : Iir_Kind) return Iir
+   is
+      Res : Iir;
+   begin
+      Res := Create_Std_Iir (Kind);
+      Set_Parent (Res, Standard_Package);
+      return Res;
+   end Create_Std_Decl;
+
    procedure Create_First_Nodes
    is
    begin
@@ -139,7 +148,7 @@
          Res : Iir_Enumeration_Literal;
          List : Iir_List;
       begin
-         Res := Create_Std_Iir (Iir_Kind_Enumeration_Literal);
+         Res := Create_Std_Decl (Iir_Kind_Enumeration_Literal);
          List := Get_Enumeration_Literal_List (Sub_Type);
          Set_Std_Identifier (Res, Name);
          Set_Type (Res, Sub_Type);
@@ -189,7 +198,7 @@
          Set_Signal_Type_Flag (Type_Definition, True);
          Set_Has_Signal_Flag (Type_Definition, not Flags.Flag_Whole_Analyze);
 
-         Type_Decl := Create_Std_Iir (Iir_Kind_Anonymous_Type_Declaration);
+         Type_Decl := Create_Std_Decl (Iir_Kind_Anonymous_Type_Declaration);
          Set_Identifier (Type_Decl, Type_Name);
          Set_Type (Type_Decl, Type_Definition);
          Set_Type_Declarator (Type_Definition, Type_Decl);
@@ -218,7 +227,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          --  type is
-         Subtype_Decl := Create_Std_Iir (Iir_Kind_Subtype_Declaration);
+         Subtype_Decl := Create_Std_Decl (Iir_Kind_Subtype_Declaration);
          Set_Std_Identifier (Subtype_Decl, Get_Identifier (Type_Decl));
          Set_Type (Subtype_Decl, Subtype_Definition);
          Set_Type_Declarator (Subtype_Definition, Subtype_Decl);
@@ -279,7 +288,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          -- type boolean is
-         Boolean_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         Boolean_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (Boolean_Type, Name_Boolean);
          Set_Type (Boolean_Type, Boolean_Type_Definition);
          Add_Decl (Boolean_Type);
@@ -308,7 +317,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          -- type bit is
-         Bit_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         Bit_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (Bit_Type, Name_Bit);
          Set_Type (Bit_Type, Bit_Type_Definition);
          Add_Decl (Bit_Type);
@@ -352,7 +361,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          -- type character is
-         Character_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         Character_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (Character_Type, Name_Character);
          Set_Type (Character_Type, Character_Type_Definition);
          Add_Decl (Character_Type);
@@ -388,7 +397,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          -- type severity_level is
-         Severity_Level_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         Severity_Level_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (Severity_Level_Type, Name_Severity_Level);
          Set_Type (Severity_Level_Type, Severity_Level_Type_Definition);
          Add_Decl (Severity_Level_Type);
@@ -435,7 +444,7 @@
          Set_Has_Signal_Flag (Universal_Real_Type_Definition, False);
 
          Universal_Real_Type :=
-           Create_Std_Iir (Iir_Kind_Anonymous_Type_Declaration);
+           Create_Std_Decl (Iir_Kind_Anonymous_Type_Declaration);
          Set_Identifier (Universal_Real_Type, Name_Universal_Real);
          Set_Type (Universal_Real_Type, Universal_Real_Type_Definition);
          Set_Type_Declarator (Universal_Real_Type_Definition,
@@ -457,7 +466,7 @@
 
          --  type is
          Universal_Real_Subtype :=
-           Create_Std_Iir (Iir_Kind_Subtype_Declaration);
+           Create_Std_Decl (Iir_Kind_Subtype_Declaration);
          Set_Identifier (Universal_Real_Subtype, Name_Universal_Real);
          Set_Type (Universal_Real_Subtype, Universal_Real_Subtype_Definition);
          Set_Type_Declarator (Universal_Real_Subtype_Definition,
@@ -492,7 +501,7 @@
          Set_Has_Signal_Flag (Convertible_Real_Type_Definition, False);
 
          Convertible_Real_Type :=
-           Create_Std_Iir (Iir_Kind_Anonymous_Type_Declaration);
+           Create_Std_Decl (Iir_Kind_Anonymous_Type_Declaration);
          Set_Identifier (Convertible_Real_Type, Name_Convertible_Real);
          Set_Type (Convertible_Real_Type, Convertible_Real_Type_Definition);
          Set_Type_Declarator (Convertible_Real_Type_Definition,
@@ -531,7 +540,7 @@
          Set_Has_Signal_Flag (Real_Type_Definition,
                               not Flags.Flag_Whole_Analyze);
 
-         Real_Type := Create_Std_Iir (Iir_Kind_Anonymous_Type_Declaration);
+         Real_Type := Create_Std_Decl (Iir_Kind_Anonymous_Type_Declaration);
          Set_Identifier (Real_Type, Name_Real);
          Set_Type (Real_Type, Real_Type_Definition);
          Set_Type_Declarator (Real_Type_Definition, Real_Type);
@@ -552,7 +561,7 @@
          Set_Has_Signal_Flag (Real_Subtype_Definition,
                               not Flags.Flag_Whole_Analyze);
 
-         Real_Subtype := Create_Std_Iir (Iir_Kind_Subtype_Declaration);
+         Real_Subtype := Create_Std_Decl (Iir_Kind_Subtype_Declaration);
          Set_Std_Identifier (Real_Subtype, Name_Real);
          Set_Type (Real_Subtype, Real_Subtype_Definition);
          Set_Type_Declarator (Real_Subtype_Definition, Real_Subtype);
@@ -579,7 +588,7 @@
          Set_Has_Signal_Flag (Natural_Subtype_Definition,
                               not Flags.Flag_Whole_Analyze);
 
-         Natural_Subtype := Create_Std_Iir (Iir_Kind_Subtype_Declaration);
+         Natural_Subtype := Create_Std_Decl (Iir_Kind_Subtype_Declaration);
          Set_Std_Identifier (Natural_Subtype, Name_Natural);
          Set_Type (Natural_Subtype, Natural_Subtype_Definition);
          Add_Decl (Natural_Subtype);
@@ -605,7 +614,7 @@
          Set_Has_Signal_Flag (Positive_Subtype_Definition,
                               not Flags.Flag_Whole_Analyze);
 
-         Positive_Subtype := Create_Std_Iir (Iir_Kind_Subtype_Declaration);
+         Positive_Subtype := Create_Std_Decl (Iir_Kind_Subtype_Declaration);
          Set_Std_Identifier (Positive_Subtype, Name_Positive);
          Set_Type (Positive_Subtype, Positive_Subtype_Definition);
          Add_Decl (Positive_Subtype);
@@ -628,7 +637,7 @@
          Set_Has_Signal_Flag (String_Type_Definition,
                               not Flags.Flag_Whole_Analyze);
 
-         String_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         String_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (String_Type, Name_String);
          Set_Type (String_Type, String_Type_Definition);
          Add_Decl (String_Type);
@@ -653,7 +662,7 @@
          Set_Has_Signal_Flag (Bit_Vector_Type_Definition,
                               not Flags.Flag_Whole_Analyze);
 
-         Bit_Vector_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         Bit_Vector_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (Bit_Vector_Type, Name_Bit_Vector);
          Set_Type (Bit_Vector_Type, Bit_Vector_Type_Definition);
          Add_Decl (Bit_Vector_Type);
@@ -748,7 +757,7 @@
          Create_Unit (Time_Hr_Unit, 60, Time_Min_Unit, Name_Hr);
 
          --  type is
-         Time_Type := Create_Std_Iir (Iir_Kind_Anonymous_Type_Declaration);
+         Time_Type := Create_Std_Decl (Iir_Kind_Anonymous_Type_Declaration);
          Set_Identifier (Time_Type, Name_Time);
          Set_Type (Time_Type, Time_Type_Definition);
          Set_Type_Declarator (Time_Type_Definition, Time_Type);
@@ -773,7 +782,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          --  subtype
-         Time_Subtype := Create_Std_Iir (Iir_Kind_Subtype_Declaration);
+         Time_Subtype := Create_Std_Decl (Iir_Kind_Subtype_Declaration);
          Set_Std_Identifier (Time_Subtype, Name_Time);
          Set_Type (Time_Subtype, Time_Subtype_Definition);
          Set_Type_Declarator (Time_Subtype_Definition, Time_Subtype);
@@ -824,7 +833,7 @@
                                  not Flags.Flag_Whole_Analyze);
 
             Delay_Length_Subtype :=
-              Create_Std_Iir (Iir_Kind_Subtype_Declaration);
+              Create_Std_Decl (Iir_Kind_Subtype_Declaration);
             Set_Std_Identifier (Delay_Length_Subtype, Name_Delay_Length);
             Set_Type (Delay_Length_Subtype, Delay_Length_Subtype_Definition);
             Set_Type_Declarator
@@ -844,7 +853,7 @@
          Function_Now : Iir_Implicit_Function_Declaration;
       begin
          Function_Now :=
-           Create_Std_Iir (Iir_Kind_Implicit_Function_Declaration);
+           Create_Std_Decl (Iir_Kind_Implicit_Function_Declaration);
          Set_Std_Identifier (Function_Now, Std_Names.Name_Now);
          if Flags.Vhdl_Std = Vhdl_87 then
             Set_Return_Type (Function_Now, Time_Subtype_Definition);
@@ -883,7 +892,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          --  type file_open_kind is
-         File_Open_Kind_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         File_Open_Kind_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (File_Open_Kind_Type, Name_File_Open_Kind);
          Set_Type (File_Open_Kind_Type, File_Open_Kind_Type_Definition);
          Add_Decl (File_Open_Kind_Type);
@@ -925,7 +934,7 @@
                               not Flags.Flag_Whole_Analyze);
 
          --  type file_open_kind is
-         File_Open_Status_Type := Create_Std_Iir (Iir_Kind_Type_Declaration);
+         File_Open_Status_Type := Create_Std_Decl (Iir_Kind_Type_Declaration);
          Set_Std_Identifier (File_Open_Status_Type, Name_File_Open_Status);
          Set_Type (File_Open_Status_Type, File_Open_Status_Type_Definition);
          Add_Decl (File_Open_Status_Type);
@@ -946,7 +955,7 @@
       --  VHDL93:
       --  attribute FOREIGN: string;
       if Flags.Vhdl_Std >= Vhdl_93c then
-         Foreign_Attribute := Create_Std_Iir (Iir_Kind_Attribute_Declaration);
+         Foreign_Attribute := Create_Std_Decl (Iir_Kind_Attribute_Declaration);
          Set_Std_Identifier (Foreign_Attribute, Name_Foreign);
          Set_Type (Foreign_Attribute, String_Type_Definition);
          Add_Decl (Foreign_Attribute);
diff -urN ghdl-0.23/vhdl/trans_decls.ads ghdl-0.23dev/vhdl/trans_decls.ads
--- ghdl-0.23/vhdl/trans_decls.ads	2005-09-22 23:45:43.000000000 +0200
+++ ghdl-0.23dev/vhdl/trans_decls.ads	2006-06-20 13:58:01.000000000 +0200
@@ -77,6 +77,14 @@
    Ghdl_Signal_Associate_E8 : O_Dnode;
    Ghdl_Signal_Driving_Value_E8 : O_Dnode;
 
+   Ghdl_Create_Signal_E32 : O_Dnode;
+   Ghdl_Signal_Init_E32 : O_Dnode;
+   Ghdl_Signal_Simple_Assign_E32 : O_Dnode;
+   Ghdl_Signal_Start_Assign_E32 : O_Dnode;
+   Ghdl_Signal_Next_Assign_E32 : O_Dnode;
+   Ghdl_Signal_Associate_E32 : O_Dnode;
+   Ghdl_Signal_Driving_Value_E32 : O_Dnode;
+
    Ghdl_Create_Signal_B2 : O_Dnode;
    Ghdl_Signal_Init_B2 : O_Dnode;
    Ghdl_Signal_Simple_Assign_B2 : O_Dnode;
@@ -190,6 +198,7 @@
    --  'Image attributes.
    Ghdl_Image_B2 : O_Dnode;
    Ghdl_Image_E8 : O_Dnode;
+   Ghdl_Image_E32 : O_Dnode;
    Ghdl_Image_I32 : O_Dnode;
    Ghdl_Image_P32 : O_Dnode;
    Ghdl_Image_P64 : O_Dnode;
@@ -198,6 +207,7 @@
    --  'Value attributes
    Ghdl_Value_B2 : O_Dnode;
    Ghdl_Value_E8 : O_Dnode;
+   Ghdl_Value_E32 : O_Dnode;
    Ghdl_Value_I32 : O_Dnode;
    Ghdl_Value_P32 : O_Dnode;
    Ghdl_Value_P64 : O_Dnode;
diff -urN ghdl-0.23/vhdl/translation.adb ghdl-0.23dev/vhdl/translation.adb
--- ghdl-0.23/vhdl/translation.adb	2006-05-16 06:26:55.000000000 +0200
+++ ghdl-0.23dev/vhdl/translation.adb	2006-06-20 13:58:01.000000000 +0200
@@ -6663,7 +6663,10 @@
             case Get_Kind (El) is
                when Iir_Kind_Function_Declaration
                  | Iir_Kind_Procedure_Declaration =>
-                  Chap2.Translate_Subprogram_Declaration (El);
+                  --  Translate only if used.
+                  if Get_Info (El) /= null then
+                     Chap2.Translate_Subprogram_Declaration (El);
+                  end if;
                when others =>
                   Error_Kind ("translate_protected_type_subprograms", El);
             end case;
@@ -8132,10 +8135,11 @@
                   end;
                when Type_Mode_Fat_Array =>
                   --  a fat array.
+                  D := Stabilize (Dest);
                   Gen_Memcpy
-                    (M2Addr (Get_Array_Base (Dest)),
+                    (M2Addr (Get_Array_Base (D)),
                      M2Addr (Get_Array_Base (E2M (Src, Info, Kind))),
-                     Get_Object_Size (Dest, Obj_Type));
+                     Get_Object_Size (D, Obj_Type));
                when Type_Mode_Record
                  | Type_Mode_Ptr_Array =>
                   Gen_Memcpy
@@ -9431,6 +9435,9 @@
             when Type_Mode_E8 =>
                Create_Subprg := Ghdl_Create_Signal_E8;
                Conv := Ghdl_I32_Type;
+            when Type_Mode_E32 =>
+               Create_Subprg := Ghdl_Create_Signal_E32;
+               Conv := Ghdl_I32_Type;
             when Type_Mode_I32
               | Type_Mode_P32 =>
                Create_Subprg := Ghdl_Create_Signal_I32;
@@ -10623,11 +10630,7 @@
                when Iir_Kind_Procedure_Declaration
                  | Iir_Kind_Function_Declaration =>
                   --  Translate interfaces.
-                  if Flag_Discard_Unused
-                    and then not Get_Use_Flag (El)
-                  then
-                     null;
-                  else
+                  if not Flag_Discard_Unused or else Get_Use_Flag (El) then
                      Info := Add_Info (El, Kind_Subprg);
                      Chap2.Translate_Subprogram_Interfaces (El);
                      if Get_Kind (El) = Iir_Kind_Function_Declaration
@@ -10660,18 +10663,16 @@
             case Get_Kind (El) is
                when Iir_Kind_Procedure_Declaration
                  | Iir_Kind_Function_Declaration =>
+                  --  Translate only if used.
                   if Get_Info (El) /= null then
                      Chap2.Translate_Subprogram_Declaration (El);
                      Translate_Resolution_Function (El, Block);
                   end if;
                when Iir_Kind_Function_Body
                  | Iir_Kind_Procedure_Body =>
-                  if Flag_Discard_Unused
-                    and then
-                    not Get_Use_Flag (Get_Subprogram_Specification (El))
+                  if not Flag_Discard_Unused
+                    or else Get_Use_Flag (Get_Subprogram_Specification (El))
                   then
-                     null;
-                  else
                      Chap2.Translate_Subprogram_Body (El);
                      Translate_Resolution_Function_Body
                        (Get_Subprogram_Specification (El), Block);
@@ -11478,6 +11479,9 @@
                   when Type_Mode_E8 =>
                      Subprg := Ghdl_Signal_Associate_E8;
                      Conv := Ghdl_I32_Type;
+                  when Type_Mode_E32 =>
+                     Subprg := Ghdl_Signal_Associate_E32;
+                     Conv := Ghdl_I32_Type;
                   when Type_Mode_I32 =>
                      Subprg := Ghdl_Signal_Associate_I32;
                      Conv := Ghdl_I32_Type;
@@ -11873,6 +11877,24 @@
                      if Get_Whole_Association_Flag (Assoc) then
                         Elab_Unconstrained_Port (Formal, Get_Actual (Assoc));
                      end if;
+                  when Iir_Kind_Association_Element_Open =>
+                     Open_Temp;
+                     declare
+                        Actual_Type : Iir;
+                        Tinfo : Type_Info_Acc;
+                        Bounds : Mnode;
+                        Formal_Node : Mnode;
+                     begin
+                        Actual_Type := Get_Type (Get_Default_Value (Formal));
+                        Chap3.Create_Array_Subtype (Actual_Type, True);
+                        Tinfo := Get_Info (Actual_Type);
+                        Bounds := Chap3.Get_Array_Type_Bounds (Actual_Type);
+                        Formal_Node := Chap6.Translate_Name (Formal);
+                        New_Assign_Stmt
+                          (M2Lp (Chap3.Get_Array_Bounds (Formal_Node)),
+                           M2Addr (Bounds));
+                     end;
+                     Close_Temp;
                   when Iir_Kind_Association_Element_By_Individual =>
                      Open_Temp;
                      declare
@@ -14941,8 +14963,6 @@
       begin
          Tinfo := Get_Info (Target_Type);
          Open_Temp;
-         --  FIXME: to be removed ?
-         --Chap3.Translate_Type_Definition (Aggr_Type);
          Targ := Stabilize (Target);
          Base := Stabilize (Chap3.Get_Array_Base (Targ));
          Bounds := Stabilize (Chap3.Get_Array_Bounds (Targ));
@@ -15076,6 +15096,10 @@
          Translate_Array_Aggregate_Gen
            (Base, Bounds, Aggr, Aggr_Type, 1, Var_Index);
          Close_Temp;
+
+         --  FIXME: creating aggregate subtype is expensive and rarely used.
+         --  (one of the current use - only ? - is check_array_match).
+         Chap3.Translate_Type_Definition (Aggr_Type, False);
       end Translate_Array_Aggregate;
 
       procedure Translate_Aggregate
@@ -15197,7 +15221,8 @@
          Res_Info := Get_Info (Res_Type);
          Expr_Info := Get_Info (Expr_Type);
          case Res_Info.Type_Mode is
-            when Type_Mode_Array =>
+            when Type_Mode_Array
+              | Type_Mode_Ptr_Array =>
                declare
                   E : O_Dnode;
                begin
@@ -19427,6 +19452,9 @@
             when Type_Mode_E8 =>
                Subprg := Ghdl_Signal_Simple_Assign_E8;
                Conv := Ghdl_I32_Type;
+            when Type_Mode_E32 =>
+               Subprg := Ghdl_Signal_Simple_Assign_E32;
+               Conv := Ghdl_I32_Type;
             when Type_Mode_I32
               | Type_Mode_P32 =>
                Subprg := Ghdl_Signal_Simple_Assign_I32;
@@ -19549,6 +19577,9 @@
             when Type_Mode_E8 =>
                Subprg := Ghdl_Signal_Start_Assign_E8;
                Conv := Ghdl_I32_Type;
+            when Type_Mode_E32 =>
+               Subprg := Ghdl_Signal_Start_Assign_E32;
+               Conv := Ghdl_I32_Type;
             when Type_Mode_I32
               | Type_Mode_P32 =>
                Subprg := Ghdl_Signal_Start_Assign_I32;
@@ -19715,6 +19746,9 @@
             when Type_Mode_E8 =>
                Subprg := Ghdl_Signal_Next_Assign_E8;
                Conv := Ghdl_I32_Type;
+            when Type_Mode_E32 =>
+               Subprg := Ghdl_Signal_Next_Assign_E32;
+               Conv := Ghdl_I32_Type;
             when Type_Mode_I32
               | Type_Mode_P32 =>
                Subprg := Ghdl_Signal_Next_Assign_I32;
@@ -21030,6 +21064,9 @@
                when Type_Mode_E8 =>
                   Init_Subprg := Ghdl_Signal_Init_E8;
                   Conv := Ghdl_I32_Type;
+               when Type_Mode_E32 =>
+                  Init_Subprg := Ghdl_Signal_Init_E32;
+                  Conv := Ghdl_I32_Type;
                when Type_Mode_I32
                  | Type_Mode_P32 =>
                   Init_Subprg := Ghdl_Signal_Init_I32;
@@ -22848,6 +22885,8 @@
                Subprg := Ghdl_Signal_Driving_Value_B2;
             when Type_Mode_E8 =>
                Subprg := Ghdl_Signal_Driving_Value_E8;
+            when Type_Mode_E32 =>
+               Subprg := Ghdl_Signal_Driving_Value_E32;
             when Type_Mode_I32
               | Type_Mode_P32 =>
                Subprg := Ghdl_Signal_Driving_Value_I32;
@@ -22904,6 +22943,9 @@
             when Type_Mode_E8 =>
                Subprg := Ghdl_Image_E8;
                Conv := Ghdl_I32_Type;
+            when Type_Mode_E32 =>
+               Subprg := Ghdl_Image_E32;
+               Conv := Ghdl_I32_Type;
             when Type_Mode_I32 =>
                Subprg := Ghdl_Image_I32;
                Conv := Ghdl_I32_Type;
@@ -22958,6 +23000,8 @@
                Subprg := Ghdl_Value_B2;
             when Type_Mode_E8 =>
                Subprg := Ghdl_Value_E8;
+            when Type_Mode_E32 =>
+               Subprg := Ghdl_Value_E32;
             when Type_Mode_I32 =>
                Subprg := Ghdl_Value_I32;
             when Type_Mode_P64 =>
@@ -26585,6 +26629,12 @@
       Create_Image_Value_Subprograms
         ("e8", Ghdl_I32_Type, True, Ghdl_Image_E8, Ghdl_Value_E8);
 
+      --  procedure __ghdl_image_e32 (res : std_string_ptr_node;
+      --                             val : ghdl_i32_type;
+      --                             rti : ghdl_rti_access);
+      Create_Image_Value_Subprograms
+        ("e32", Ghdl_I32_Type, True, Ghdl_Image_E32, Ghdl_Value_E32);
+
       --  procedure __ghdl_image_i32 (res : std_string_ptr_node;
       --                              val : ghdl_i32_type);
       Create_Image_Value_Subprograms
@@ -26919,6 +26969,19 @@
                                  Ghdl_Signal_Associate_E8,
                                  Ghdl_Signal_Driving_Value_E8);
 
+      --  function __ghdl_create_signal_enum8 (init_val : ghdl_i32_type)
+      --                                       return __ghdl_signal_ptr;
+      --  procedure __ghdl_signal_simple_assign_e8 (sign : __ghdl_signal_ptr;
+      --                                            val : __ghdl_integer);
+      Create_Signal_Subprograms ("e32", Ghdl_I32_Type,
+                                 Ghdl_Create_Signal_E32,
+                                 Ghdl_Signal_Init_E32,
+                                 Ghdl_Signal_Simple_Assign_E32,
+                                 Ghdl_Signal_Start_Assign_E32,
+                                 Ghdl_Signal_Next_Assign_E32,
+                                 Ghdl_Signal_Associate_E32,
+                                 Ghdl_Signal_Driving_Value_E32);
+
       --  function __ghdl_create_signal_b2 (init_val : ghdl_bool_type)
       --                                    return __ghdl_signal_ptr;
       --  procedure __ghdl_signal_simple_assign_b2 (sign : __ghdl_signal_ptr;
@@ -27699,6 +27762,7 @@
          begin
             --  Load the unit in memory to compute the dependence list.
             Libraries.Load_Design_Unit (Unit, Null_Iir);
+            Update_Node_Infos;
 
             Set_Elab_Flag (Unit, True);
             Design_Units.Append (Unit);
diff -urN ghdl-0.23/vhdl/version.ads ghdl-0.23dev/vhdl/version.ads
--- ghdl-0.23/vhdl/version.ads	2006-05-16 06:30:19.000000000 +0200
+++ ghdl-0.23dev/vhdl/version.ads	2006-06-20 13:58:05.000000000 +0200
@@ -1,4 +1,4 @@
 package Version is
    Ghdl_Version : constant String :=
-      "GHDL 0.23 (20060516) [Sokcho edition]";
+      "GHDL 0.23dev (20060614) [Sokcho edition]";
 end Version;
