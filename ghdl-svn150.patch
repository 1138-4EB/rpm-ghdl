diff -urN ghdl-0.29/README ghdl-0.30dev/README
--- ghdl-0.29/README	2010-01-09 15:32:28.000000000 +0100
+++ ghdl-0.30dev/README	2013-01-30 21:51:02.000000000 +0100
@@ -27,7 +27,7 @@
 ***************************
 
 Required:
-* the sources of gcc-4.3.4 (at least the core part).
+* the sources of gcc-4.7.2 (at least the core part).
   Note: other versions of gcc sources have not been tested.
 * the Ada95 GNAT compiler (GNAT GPL 2008 are known to work;
   Ada compilers in most Linux distributions are more or less buggy)
@@ -53,7 +53,7 @@
   file from it).
 * move or copy the vhdl directory of ghdl into the gcc subdirectory of
   the gcc distribution.
-  You should have a gcc-4.3.4/gcc/vhdl directory.
+  You should have a gcc-4.7.2/gcc/vhdl directory.
 * configure gcc with the --enable-languages=vhdl option.  You may of course
   add other languages.  Also you'd better to disable bootstraping using
   --disable-bootstrap.
diff -urN ghdl-0.29/vhdl/back_end.ads ghdl-0.30dev/vhdl/back_end.ads
--- ghdl-0.29/vhdl/back_end.ads	2009-12-29 08:07:06.000000000 +0100
+++ ghdl-0.30dev/vhdl/back_end.ads	2013-01-30 21:50:35.000000000 +0100
@@ -55,4 +55,3 @@
    type Sem_Foreign_Acc is access procedure (Decl : Iir);
    Sem_Foreign : Sem_Foreign_Acc := null;
 end Back_End;
-
diff -urN ghdl-0.29/vhdl/errorout.adb ghdl-0.30dev/vhdl/errorout.adb
--- ghdl-0.29/vhdl/errorout.adb	2009-12-29 08:07:06.000000000 +0100
+++ ghdl-0.30dev/vhdl/errorout.adb	2013-01-30 21:50:35.000000000 +0100
@@ -86,14 +86,16 @@
       raise Internal_Error;
    end Error_Kind;
 
-   -- Disp an error, prepended with program name.
-   -- This is used for errors before initialisation, such as bad option or
-   -- bad filename.
-   procedure Error_Msg_Option (Msg: String) is
+   procedure Error_Msg_Option_NR (Msg: String) is
    begin
       Put (Ada.Command_Line.Command_Name);
-      Put (":*command-line*: ");
+      Put (": ");
       Put_Line (Msg);
+   end Error_Msg_Option_NR;
+
+   procedure Error_Msg_Option (Msg: String) is
+   begin
+      Error_Msg_Option_NR (Msg);
       raise Option_Error;
    end Error_Msg_Option;
 
diff -urN ghdl-0.29/vhdl/errorout.ads ghdl-0.30dev/vhdl/errorout.ads
--- ghdl-0.29/vhdl/errorout.ads	2009-12-29 08:07:06.000000000 +0100
+++ ghdl-0.30dev/vhdl/errorout.ads	2013-01-30 21:50:35.000000000 +0100
@@ -49,6 +49,10 @@
    -- This is used for errors before initialisation, such as bad option or
    -- bad filename.
    procedure Error_Msg_Option (Msg: String);
+   pragma No_Return (Error_Msg_Option);
+
+   --  Same as Error_Msg_Option but do not raise Option_Error.
+   procedure Error_Msg_Option_NR (Msg: String);
 
    -- Disp an error location (using AN_IIR location) using the standard
    -- format `file:line:col: '.
diff -urN ghdl-0.29/vhdl/evaluation.adb ghdl-0.30dev/vhdl/evaluation.adb
--- ghdl-0.29/vhdl/evaluation.adb	2010-01-02 16:03:58.000000000 +0100
+++ ghdl-0.30dev/vhdl/evaluation.adb	2013-01-30 21:50:36.000000000 +0100
@@ -24,7 +24,9 @@
 with Std_Names;
 
 package body Evaluation is
-   function Get_Physical_Value (Expr : Iir) return Iir_Int64 is
+   function Get_Physical_Value (Expr : Iir) return Iir_Int64
+   is
+      pragma Unsuppress (Overflow_Check);
    begin
       case Get_Kind (Expr) is
          when Iir_Kind_Physical_Int_Literal =>
@@ -35,6 +37,10 @@
          when others =>
             Error_Kind ("get_physical_value", Expr);
       end case;
+   exception
+      when Constraint_Error =>
+         Error_Msg_Sem ("arithmetic overflow in physical expression", Expr);
+         return Get_Value (Expr);
    end Get_Physical_Value;
 
    function Build_Integer (Val : Iir_Int64; Origin : Iir)
diff -urN ghdl-0.29/vhdl/ghdldrv/ghdldrv.adb ghdl-0.30dev/vhdl/ghdldrv/ghdldrv.adb
--- ghdl-0.29/vhdl/ghdldrv/ghdldrv.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/ghdldrv/ghdldrv.adb	2013-01-30 21:50:36.000000000 +0100
@@ -671,6 +671,11 @@
          Add_Argument (Compiler_Args, new String'(Opt));
          Flag_Expect_Failure := True;
          Res := Option_Ok;
+      elsif Opt = "-C" then
+         --  Translate -C into --mb-comments, as gcc already has a definition
+         --  for -C.  Done before Flags.Parse_Option.
+         Add_Argument (Compiler_Args, new String'("--mb-comments"));
+         Res := Option_Ok;
       elsif Options.Parse_Option (Opt) then
          Add_Argument (Compiler_Args, new String'(Opt));
          Res := Option_Ok;
@@ -888,22 +893,21 @@
 
    procedure Bind_Anaelab (Files : Argument_List)
    is
-      Comp_List : Argument_List (1 .. 2 * Files'Length + 2);
-      Flag_C : String_Access;
+      Comp_List : Argument_List (1 .. Files'Length + 2);
       Index : Natural;
    begin
       Comp_List (1) := new String'("--anaelab");
       Comp_List (2) := Unit_Name;
-      Flag_C := new String'("-c");
       Index := 3;
       for I in Files'Range loop
-         Comp_List (Index) := Flag_C;
-         Comp_List (Index + 1) := Files (I);
-         Index := Index + 2;
+         Comp_List (Index) := new String'("--ghdl-source=" & Files (I).all);
+         Index := Index + 1;
       end loop;
       Do_Compile (Comp_List, Elab_Name.all);
-      Free (Flag_C);
       Free (Comp_List (1));
+      for I in 3 .. Comp_List'Last loop
+         Free (Comp_List (I));
+      end loop;
    end Bind_Anaelab;
 
    procedure Link (Add_Std : Boolean;
diff -urN ghdl-0.29/vhdl/ghdldrv/ghdllocal.adb ghdl-0.30dev/vhdl/ghdldrv/ghdllocal.adb
--- ghdl-0.29/vhdl/ghdldrv/ghdllocal.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/ghdldrv/ghdllocal.adb	2013-01-30 21:50:36.000000000 +0100
@@ -1125,9 +1125,73 @@
    function Convert_Name (Name : String_Access) return String_Access
    is
       use Name_Table;
+
+      function Is_Bad_Unit_Name return Boolean is
+      begin
+         if Name_Length = 0 then
+            return True;
+         end if;
+         --  Don't try to handle extended identifier.
+         if Name_Buffer (1) = '\' then
+            return False;
+         end if;
+         --  Look for suspicious characters.
+         --  Do not try to be exhaustive as the correct check will be done
+         --  by convert_identifier.
+         for I in 1 .. Name_Length loop
+            case Name_Buffer (I) is
+               when '.' | '/' | '\' =>
+                  return True;
+               when others =>
+                  null;
+            end case;
+         end loop;
+         return False;
+      end Is_Bad_Unit_Name;
+
+      function Is_A_File_Name return Boolean is
+      begin
+         --  Check .vhd
+         if Name_Length > 4
+           and then Name_Buffer (Name_Length - 3 .. Name_Length) = ".vhd"
+         then
+            return True;
+         end if;
+         --  Check .vhdl
+         if Name_Length > 5
+           and then Name_Buffer (Name_Length - 4 .. Name_Length) = ".vhdl"
+         then
+            return True;
+         end if;
+         --  Check ../
+         if Name_Length > 3
+           and then Name_Buffer (1 .. 3) = "../"
+         then
+            return True;
+         end if;
+         --  Check ..\
+         if Name_Length > 3
+           and then Name_Buffer (1 .. 3) = "..\"
+         then
+            return True;
+         end if;
+         --  Should try to find the file ?
+         return False;
+      end Is_A_File_Name;
    begin
       Name_Length := Name'Length;
       Name_Buffer (1 .. Name_Length) := Name.all;
+
+      --  Try to identifier bad names (such as file names), so that
+      --  friendly message can be displayed.
+      if Is_Bad_Unit_Name then
+         Errorout.Error_Msg_Option_NR ("bad unit name '" & Name.all & "'");
+         if Is_A_File_Name then
+            Errorout.Error_Msg_Option_NR
+              ("(a unit name is required instead of a filename)");
+         end if;
+         raise Option_Error;
+      end if;
       Scan.Convert_Identifier;
       return new String'(Name_Buffer (1 .. Name_Length));
    end Convert_Name;
diff -urN ghdl-0.29/vhdl/ghdldrv/ghdlprint.ads ghdl-0.30dev/vhdl/ghdldrv/ghdlprint.ads
--- ghdl-0.29/vhdl/ghdldrv/ghdlprint.ads	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/ghdldrv/ghdlprint.ads	2013-01-30 21:50:36.000000000 +0100
@@ -18,5 +18,3 @@
 package Ghdlprint is
    procedure Register_Commands;
 end Ghdlprint;
-
-
diff -urN ghdl-0.29/vhdl/ghdl.texi ghdl-0.30dev/vhdl/ghdl.texi
--- ghdl-0.29/vhdl/ghdl.texi	2010-01-09 15:11:15.000000000 +0100
+++ ghdl-0.30dev/vhdl/ghdl.texi	2013-01-30 21:50:35.000000000 +0100
@@ -1931,7 +1931,8 @@
 @node PSL implementation, Source representation, VHDL standards, GHDL implementation of VHDL
 @comment  node-name,  next,  previous,  up
 @section PSL implementation
-GHDL understands embedded PSL annotations in VHDL files, but in separate files.
+GHDL understands embedded PSL annotations in VHDL files, but not in
+separate files.
 
 As PSL annotations are embedded within comments, you must analyze and elaborate
 your design with option @option{-fpsl} to enable PSL annotations.
@@ -1941,8 +1942,8 @@
 same line) by a PSL keyword such as @code{assert} or @code{default}.
 To continue a PSL statement on the next line, just start a new comment.
 
-A PSL statement is considered as a concurrent statement, and therefore is
-allowed only where processes are.
+A PSL statement is considered as a process.  So it is not allowed within
+a process.
 
 All PSL assertions must be clocked (GHDL doesn't support unclocked assertion).
 Furthermore only one clock per assertion is allowed.
diff -urN ghdl-0.29/vhdl/grt/grt-cbinding.c ghdl-0.30dev/vhdl/grt/grt-cbinding.c
--- ghdl-0.29/vhdl/grt/grt-cbinding.c	2010-01-01 04:44:49.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-cbinding.c	2013-01-30 21:50:36.000000000 +0100
@@ -18,6 +18,7 @@
 */
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 
 FILE *
 __ghdl_get_stdout (void)
@@ -56,7 +57,7 @@
   fprintf (stream, "%3d.%03d", a, b);
 }
 
-#if 1
+#ifndef WITH_GNAT_RUN_TIME
 void
 __gnat_last_chance_handler (void)
 {
diff -urN ghdl-0.29/vhdl/grt/grt-disp_signals.adb ghdl-0.30dev/vhdl/grt/grt-disp_signals.adb
--- ghdl-0.29/vhdl/grt/grt-disp_signals.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-disp_signals.adb	2013-01-30 21:50:36.000000000 +0100
@@ -110,6 +110,9 @@
       end case;
    end Disp_Context;
 
+   --  This is a debugging procedure.
+   pragma Unreferenced (Disp_Context);
+
    --  Option --trace-signals.
 
    --  Disp transaction TRANS from signal SIG.
diff -urN ghdl-0.29/vhdl/grt/grt-processes.adb ghdl-0.30dev/vhdl/grt/grt-processes.adb
--- ghdl-0.29/vhdl/grt/grt-processes.adb	2010-01-06 05:12:24.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-processes.adb	2013-01-30 21:50:36.000000000 +0100
@@ -23,7 +23,6 @@
 with Grt.Disp;
 with Grt.Astdio;
 with Grt.Errors; use Grt.Errors;
-with Grt.Stacks; use Grt.Stacks;
 with Grt.Options;
 with Grt.Rtis_Addr; use Grt.Rtis_Addr;
 with Grt.Rtis_Utils;
@@ -46,15 +45,12 @@
       Table_Low_Bound => 1,
       Table_Initial => 16);
 
-   function To_Proc_Acc is new Ada.Unchecked_Conversion
-     (Source => System.Address, Target => Proc_Acc);
-
    type Finalizer_Type is record
       --  Subprogram containing process code.
       Subprg : Proc_Acc;
 
       --  Instance (THIS parameter) for the subprogram.
-      This : System.Address;
+      This : Instance_Acc;
    end record;
 
    --  List of finalizer.
@@ -111,8 +107,8 @@
       return Nbr_Resumed_Processes;
    end Get_Nbr_Resumed_Processes;
 
-   procedure Process_Register (This : System.Address;
-                               Proc : System.Address;
+   procedure Process_Register (This : Instance_Acc;
+                               Proc : Proc_Acc;
                                Ctxt : Rti_Context;
                                State : Process_State;
                                Postponed : Boolean)
@@ -128,7 +124,7 @@
       else
          Stack := Null_Stack;
       end if;
-      P := new Process_Type'(Subprg => To_Proc_Acc (Proc),
+      P := new Process_Type'(Subprg => Proc,
                              This => This,
                              Rti => Ctxt,
                              Sensitivity => null,
@@ -150,8 +146,8 @@
    end Process_Register;
 
    procedure Ghdl_Process_Register
-     (Instance : System.Address;
-      Proc : System.Address;
+     (Instance : Instance_Acc;
+      Proc : Proc_Acc;
       Ctxt : Ghdl_Rti_Access;
       Addr : System.Address)
    is
@@ -160,8 +156,8 @@
    end Ghdl_Process_Register;
 
    procedure Ghdl_Sensitized_Process_Register
-     (Instance : System.Address;
-      Proc : System.Address;
+     (Instance : Instance_Acc;
+      Proc : Proc_Acc;
       Ctxt : Ghdl_Rti_Access;
       Addr : System.Address)
    is
@@ -170,8 +166,8 @@
    end Ghdl_Sensitized_Process_Register;
 
    procedure Ghdl_Postponed_Process_Register
-     (Instance : System.Address;
-      Proc : System.Address;
+     (Instance : Instance_Acc;
+      Proc : Proc_Acc;
       Ctxt : Ghdl_Rti_Access;
       Addr : System.Address)
    is
@@ -180,8 +176,8 @@
    end Ghdl_Postponed_Process_Register;
 
    procedure Ghdl_Postponed_Sensitized_Process_Register
-     (Instance : System.Address;
-      Proc : System.Address;
+     (Instance : Instance_Acc;
+      Proc : Proc_Acc;
       Ctxt : Ghdl_Rti_Access;
       Addr : System.Address)
    is
@@ -189,12 +185,10 @@
       Process_Register (Instance, Proc, (Addr, Ctxt), State_Sensitized, True);
    end Ghdl_Postponed_Sensitized_Process_Register;
 
-   procedure Verilog_Process_Register (This : System.Address;
-                                       Proc : System.Address;
+   procedure Verilog_Process_Register (This : Instance_Acc;
+                                       Proc : Proc_Acc;
                                        Ctxt : Rti_Context)
    is
-      function To_Proc_Acc is new Ada.Unchecked_Conversion
-        (Source => System.Address, Target => Proc_Acc);
       P : Process_Acc;
    begin
       P := new Process_Type'(Rti => Ctxt,
@@ -205,7 +199,7 @@
                              Timeout => Bad_Time,
                              Timeout_Chain_Next => null,
                              Timeout_Chain_Prev => null,
-                             Subprg => To_Proc_Acc (Proc),
+                             Subprg => Proc,
                              This => This,
                              Stack => Null_Stack);
       Process_Table.Append (P);
@@ -213,15 +207,15 @@
       Set_Current_Process (P);
    end Verilog_Process_Register;
 
-   procedure Ghdl_Initial_Register (Instance : System.Address;
-                                    Proc : System.Address)
+   procedure Ghdl_Initial_Register (Instance : Instance_Acc;
+                                    Proc : Proc_Acc)
    is
    begin
       Verilog_Process_Register (Instance, Proc, Null_Context);
    end Ghdl_Initial_Register;
 
-   procedure Ghdl_Always_Register (Instance : System.Address;
-                                   Proc : System.Address)
+   procedure Ghdl_Always_Register (Instance : Instance_Acc;
+                                   Proc : Proc_Acc)
    is
    begin
       Verilog_Process_Register (Instance, Proc, Null_Context);
@@ -234,11 +228,11 @@
         (Sig, Process_Table.Table (Process_Table.Last));
    end Ghdl_Process_Add_Sensitivity;
 
-   procedure Ghdl_Finalize_Register (Instance : System.Address;
-                                     Proc : System.Address)
+   procedure Ghdl_Finalize_Register (Instance : Instance_Acc;
+                                     Proc : Proc_Acc)
    is
    begin
-      Finalizer_Table.Append (Finalizer_Type'(To_Proc_Acc (Proc), Instance));
+      Finalizer_Table.Append (Finalizer_Type'(Proc, Instance));
    end Ghdl_Finalize_Register;
 
    procedure Call_Finalizers is
@@ -667,7 +661,7 @@
             Grt.Astdio.Put ("run process ");
             Disp_Process_Name (Stdio.stdout, Proc);
             Grt.Astdio.Put (" [");
-            Grt.Astdio.Put (Stdio.stdout, Proc.This);
+            Grt.Astdio.Put (Stdio.stdout, To_Address (Proc.This));
             Grt.Astdio.Put ("]");
             Grt.Astdio.New_Line;
          end if;
@@ -720,7 +714,7 @@
                   Grt.Astdio.Put ("run process ");
                   Disp_Process_Name (Stdio.stdout, Proc);
                   Grt.Astdio.Put (" [");
-                  Grt.Astdio.Put (Stdio.stdout, Proc.This);
+                  Grt.Astdio.Put (Stdio.stdout, To_Address (Proc.This));
                   Grt.Astdio.Put ("]");
                   Grt.Astdio.New_Line;
                end if;
diff -urN ghdl-0.29/vhdl/grt/grt-processes.ads ghdl-0.30dev/vhdl/grt/grt-processes.ads
--- ghdl-0.29/vhdl/grt/grt-processes.ads	2010-01-06 04:55:54.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-processes.ads	2013-01-30 21:50:36.000000000 +0100
@@ -19,7 +19,7 @@
 with Grt.Stack2; use Grt.Stack2;
 with Grt.Types; use Grt.Types;
 with Grt.Signals; use Grt.Signals;
-with Grt.Stacks;
+with Grt.Stacks; use Grt.Stacks;
 with Grt.Rtis; use Grt.Rtis;
 with Grt.Rtis_Addr;
 with Grt.Stdio;
@@ -63,31 +63,32 @@
 
    --  Register a process during elaboration.
    --  This procedure is called by vhdl elaboration code.
-   procedure Ghdl_Process_Register (Instance : System.Address;
-                                    Proc : System.Address;
+   procedure Ghdl_Process_Register (Instance : Instance_Acc;
+                                    Proc : Proc_Acc;
                                     Ctxt : Ghdl_Rti_Access;
                                     Addr : System.Address);
-   procedure Ghdl_Sensitized_Process_Register (Instance : System.Address;
-                                               Proc : System.Address;
+   procedure Ghdl_Sensitized_Process_Register (Instance : Instance_Acc;
+                                               Proc : Proc_Acc;
                                                Ctxt : Ghdl_Rti_Access;
                                                Addr : System.Address);
-   procedure Ghdl_Postponed_Process_Register (Instance : System.Address;
-                                              Proc : System.Address;
+   procedure Ghdl_Postponed_Process_Register (Instance : Instance_Acc;
+                                              Proc : Proc_Acc;
                                               Ctxt : Ghdl_Rti_Access;
                                               Addr : System.Address);
    procedure Ghdl_Postponed_Sensitized_Process_Register
-     (Instance : System.Address;
-      Proc : System.Address;
+     (Instance : Instance_Acc;
+      Proc : Proc_Acc;
       Ctxt : Ghdl_Rti_Access;
       Addr : System.Address);
 
-   procedure Ghdl_Finalize_Register (Instance : System.Address;
-                                     Proc : System.Address);
-
-   procedure Ghdl_Initial_Register (Instance : System.Address;
-                                    Proc : System.Address);
-   procedure Ghdl_Always_Register (Instance : System.Address;
-                                   Proc : System.Address);
+   --  For verilog processes.
+   procedure Ghdl_Finalize_Register (Instance : Instance_Acc;
+                                     Proc : Proc_Acc);
+
+   procedure Ghdl_Initial_Register (Instance : Instance_Acc;
+                                    Proc : Proc_Acc);
+   procedure Ghdl_Always_Register (Instance : Instance_Acc;
+                                   Proc : Proc_Acc);
 
    --  Add a simple signal in the sensitivity of the last registered
    --  (sensitized) process.
@@ -113,6 +114,7 @@
    --  Verilog.
    procedure Ghdl_Process_Delay (Del : Ghdl_U32);
 
+   --  Secondary stack.
    function Ghdl_Stack2_Allocate (Size : Ghdl_Index_Type)
      return System.Address;
    function Ghdl_Stack2_Mark return Mark_Id;
@@ -125,9 +127,6 @@
    procedure Ghdl_Protected_Fini (Obj : System.Address);
 
 private
-   --  Access to a process subprogram.
-   type Proc_Acc is access procedure (Self : System.Address);
-
    --  State of a process.
    type Process_State is
      (
@@ -163,7 +162,7 @@
       Subprg : Proc_Acc;
 
       --  Instance (THIS parameter) for the subprogram.
-      This : System.Address;
+      This : Instance_Acc;
 
       --  Name of the process.
       Rti : Rtis_Addr.Rti_Context;
diff -urN ghdl-0.29/vhdl/grt/grt-signals.adb ghdl-0.30dev/vhdl/grt/grt-signals.adb
--- ghdl-0.29/vhdl/grt/grt-signals.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-signals.adb	2013-01-30 21:50:36.000000000 +0100
@@ -1804,6 +1804,7 @@
    end Compute_Resolved_Signal;
 
    type Conversion_Func_Acc is access procedure (Instance : System.Address);
+   pragma Convention (C, Conversion_Func_Acc);
    function To_Conversion_Func_Acc is new Ada.Unchecked_Conversion
      (Source => System.Address, Target => Conversion_Func_Acc);
 
@@ -2470,7 +2471,7 @@
                   end if;
                end if;
             else
-               Sig.Net := Signal_Net_Type (Offs (Sig.Net));
+               Sig.Net := Offs (Sig.Net);
             end if;
             Sig.Link := null;
          end loop;
diff -urN ghdl-0.29/vhdl/grt/grt-signals.ads ghdl-0.30dev/vhdl/grt/grt-signals.ads
--- ghdl-0.29/vhdl/grt/grt-signals.ads	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-signals.ads	2013-01-30 21:50:36.000000000 +0100
@@ -76,7 +76,8 @@
 
    --  Function access type used to evaluate the guard expression.
    type Guard_Func_Acc is access function (This : System.Address)
-     return Ghdl_B2;
+                                          return Ghdl_B2;
+   pragma Convention (C, Guard_Func_Acc);
 
    --  Simply linked list of processes to be resumed in case of events.
 
diff -urN ghdl-0.29/vhdl/grt/grt-stacks.ads ghdl-0.30dev/vhdl/grt/grt-stacks.ads
--- ghdl-0.29/vhdl/grt/grt-stacks.ads	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-stacks.ads	2013-01-30 21:50:36.000000000 +0100
@@ -16,8 +16,24 @@
 --  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 --  02111-1307, USA.
 with System; use System;
+with Ada.Unchecked_Conversion;
 
 package Grt.Stacks is
+   --  Instance is the parameter of the process procedure.
+   --  This is in fact a fully opaque type whose content is private to the
+   --  process.
+   type Instance is limited private;
+   type Instance_Acc is access all Instance;
+   pragma Convention (C, Instance_Acc);
+
+   --  A process is identified by a procedure having a single private
+   --  parameter (its instance).
+   type Proc_Acc is access procedure (Self : Instance_Acc);
+   pragma Convention (C, Proc_Acc);
+
+   function To_Address is new Ada.Unchecked_Conversion
+     (Instance_Acc, System.Address);
+
    type Stack_Type is new Address;
    Null_Stack : constant Stack_Type := Stack_Type (Null_Address);
 
@@ -28,7 +44,8 @@
 
    --  Create a new stack, which on first execution will call FUNC with
    --  an argument ARG.
-   function Stack_Create (Func : Address; Arg : Address) return Stack_Type;
+   function Stack_Create (Func : Proc_Acc; Arg : Instance_Acc)
+                         return Stack_Type;
 
    --  Resume stack TO and save the current context to the stack pointed by
    --  CUR.
@@ -50,6 +67,8 @@
    procedure Error_Null_Access;
    pragma No_Return (Error_Null_Access);
 private
+   type Instance is null record;
+
    pragma Import (C, Stack_Init, "grt_stack_init");
    pragma Import (C, Stack_Create, "grt_stack_create");
    pragma Import (C, Stack_Switch, "grt_stack_switch");
diff -urN ghdl-0.29/vhdl/grt/grt-vpi.ads ghdl-0.30dev/vhdl/grt/grt-vpi.ads
--- ghdl-0.29/vhdl/grt/grt-vpi.ads	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-vpi.ads	2013-01-30 21:50:36.000000000 +0100
@@ -137,6 +137,7 @@
      (Source => Address, Target => p_cb_data);
 
    type cb_rtn_type is access function (Cb : p_cb_data) return Integer;
+   pragma Convention (C, cb_rtn_type);
 
    type s_cb_data is record
       Reason : Integer;
diff -urN ghdl-0.29/vhdl/grt/grt-waves.adb ghdl-0.30dev/vhdl/grt/grt-waves.adb
--- ghdl-0.29/vhdl/grt/grt-waves.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/grt/grt-waves.adb	2013-01-30 21:50:36.000000000 +0100
@@ -387,7 +387,7 @@
       Put_I32 (stdout, Ghdl_I32 (Str_AVL.Table (N).Right));
       New_Line (stdout);
       Put (stdout, " height: ");
-      Put_I32 (stdout, Ghdl_I32 (Str_AVL.Table (N).Height));
+      Put_I32 (stdout, Str_AVL.Table (N).Height);
       New_Line (stdout);
       Put (stdout, " str: ");
       --Put (stdout, Str_AVL.Table (N).Val);
diff -urN ghdl-0.29/vhdl/iirs_utils.ads ghdl-0.30dev/vhdl/iirs_utils.ads
--- ghdl-0.29/vhdl/iirs_utils.ads	2010-01-03 03:27:39.000000000 +0100
+++ ghdl-0.30dev/vhdl/iirs_utils.ads	2013-01-30 21:50:37.000000000 +0100
@@ -156,4 +156,3 @@
    --  IIR wrapper around Get_HDL_Node.
    function Get_HDL_Node (N : PSL_Node) return Iir;
 end Iirs_Utils;
-
diff -urN ghdl-0.29/vhdl/lang.opt ghdl-0.30dev/vhdl/lang.opt
--- ghdl-0.29/vhdl/lang.opt	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/lang.opt	2013-01-30 21:50:37.000000000 +0100
@@ -33,13 +33,14 @@
 vhdl Separate
 --anaelab <name>	Used internally during elaboration of <name>
 
-c
-vhdl Separate
--c <filename>	Analyze <filename> for --anaelab
-
-v
-vhdl
-Verbose
+; -c is a driver option for gcc.  --ghdl-source is used instead.
+;c
+;vhdl Separate
+;-c <filename>	Analyze <filename> for --anaelab
+
+;v
+;vhdl
+;Verbose
 
 -warn-
 vhdl Joined
@@ -81,9 +82,10 @@
 vhdl Joined Separate
 -l<filename>	Put list of files for link in <filename>
 
-C
-vhdl
-Allow any character in comments
+; -C was commented out, as it is already defined for C/C++.
+;C
+;vhdl
+;Allow any character in comments
 
 -mb-comments
 vhdl
diff -urN ghdl-0.29/vhdl/Makefile.in ghdl-0.30dev/vhdl/Makefile.in
--- ghdl-0.29/vhdl/Makefile.in	2010-01-09 15:32:26.000000000 +0100
+++ ghdl-0.30dev/vhdl/Makefile.in	2013-01-30 21:51:01.000000000 +0100
@@ -301,8 +301,8 @@
 	mkdir $(STD93_DIR)
 	prev=`pwd`; cd $(STD93_DIR); \
 	for i in $(STD93_SRCS); do \
-	  echo $$i; \
-	  $(ANALYZE93) --bootstrap --work=std $(REL_DIR)/$$i || exit 1; \
+	  cmd="$(ANALYZE93) --bootstrap --work=std $(REL_DIR)/$$i"; \
+	  echo $$cmd; eval $$cmd || exit 1; \
 	done; \
 	cd $$prev
 
@@ -352,8 +352,8 @@
 	mkdir $(STD87_DIR)
 	prev=`pwd`; cd $(STD87_DIR); \
 	for i in $(STD87_SRCS); do \
-	  echo $$i; \
-	  $(ANALYZE87) --bootstrap --work=std $(REL_DIR)/$$i || exit 1; \
+	  cmd="$(ANALYZE87) --bootstrap --work=std $(REL_DIR)/$$i"; \
+	  echo $$cmd; eval $$cmd || exit 1; \
 	done; \
 	cd $$prev
 
@@ -478,7 +478,11 @@
 endif
 ifeq ($(filter-out i%86 darwin%,$(arch) $(osys)),)
   GRT_TARGET_OBJS=i386.o linux.o times.o
-  GRT_EXTRA_LIB=-lm
+  GRT_EXTRA_LIB=
+endif
+ifeq ($(filter-out x84_64 darwin%,$(arch) $(osys)),)
+  GRT_TARGET_OBJS=amd64.o linux.o times.o
+  GRT_EXTRA_LIB=
 endif
 ifeq ($(filter-out sparc solaris%,$(arch) $(osys)),)
   GRT_TARGET_OBJS=sparc.o linux.o times.o
diff -urN ghdl-0.29/vhdl/Make-lang.in ghdl-0.30dev/vhdl/Make-lang.in
--- ghdl-0.29/vhdl/Make-lang.in	2010-01-09 15:32:26.000000000 +0100
+++ ghdl-0.30dev/vhdl/Make-lang.in	2013-01-30 21:51:01.000000000 +0100
@@ -122,17 +122,67 @@
 
 
 .PHONY: agcc-clean agcc-maintainer-clean
+#  -*- Makefile -*- for the gcc implemantation of ortho.
+#  Copyright (C) 2005 Tristan Gingold
+#
+#  GHDL is free software; you can redistribute it and/or modify it under
+#  the terms of the GNU General Public License as published by the Free
+#  Software Foundation; either version 2, or (at your option) any later
+#  version.
+#
+#  GHDL is distributed in the hope that it will be useful, but WITHOUT ANY
+#  WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+#  for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with GCC; see the file COPYING.  If not, write to the Free
+#  Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+#  02111-1307, USA.
+
+# Variable used:
+# AGCC_GCCSRC_DIR: the gcc source base directory (ie gcc-X.Y.Z-objs/)
+# AGCC_GCCOBJ_DIR: the gcc objects base directory
+# agcc_srcdir: the agcc source directory
+# agcc_objdir: the agcc object directory
+
+AGCC_INC_FLAGS=-I$(AGCC_GCCOBJ_DIR)/gcc -I$(AGCC_GCCSRC_DIR)/include \
+ -I$(AGCC_GCCSRC_DIR)/gcc -I$(AGCC_GCCSRC_DIR)/gcc/config \
+ -I$(AGCC_GCCSRC_DIR)/libcpp/include
+AGCC_CFLAGS=-g -Wall -DIN_GCC $(AGCC_INC_FLAGS)
+
+AGCC_LOCAL_OBJS=ortho-lang.o
+
+AGCC_DEPS := $(AGCC_LOCAL_OBJS)
+AGCC_OBJS := $(AGCC_LOCAL_OBJS) $(AGCC_GCCOBJ_DIR)gcc/attribs.o
+#	$(AGCC_GCCOBJ_DIR)gcc/toplev.o
+
+ortho-lang.o: $(agcc_srcdir)/ortho-lang.c \
+ $(AGCC_GCCOBJ_DIR)gcc/gtype-vhdl.h \
+ $(AGCC_GCCOBJ_DIR)gcc/gt-vhdl-ortho-lang.h
+	$(CC) -c -o $@ $< $(AGCC_CFLAGS)
+
+agcc-clean: force
+	$(RM) -f $(agcc_objdir)/*.o
+	$(RM) -f $(agcc_srcdir)/*~
+
+agcc-maintainer-clean: force
+	$(RM) -f $(AGCC_DEPS)
+
+
+.PHONY: agcc-clean agcc-maintainer-clean
 
 # The compiler proper.
 # It is compiled into the vhdl/ subdirectory to avoid file name clashes but
 # linked in in gcc directory to be able to access to gcc object files.
-ghdl1$(exeext): $(AGCC_OBJS) $(AGCC_DEPS) force
+ghdl1$(exeext): $(AGCC_OBJS) $(AGCC_DEPS) force $(BACKEND) $(LIBDEPS)
 	CURDIR=`pwd`; cd $(srcdir)/vhdl; VHDLSRCDIR=`pwd`; cd $$CURDIR/vhdl; \
 	$(GNATMAKE) -c -aI$$VHDLSRCDIR ortho_gcc-main \
 	 -cargs $(CFLAGS) $(GHDL_ADAFLAGS)
 	$(GNATMAKE) -o $@ -aI$(srcdir)/vhdl -aOvhdl ortho_gcc-main \
 	 -bargs -E -cargs $(CFLAGS) $(GHDL_ADAFLAGS) \
-	 -largs $(AGCC_OBJS) $(LIBS) $(GMPLIBS)
+	 -largs $(AGCC_OBJS) $(filter-out main.o,$(BACKEND)) \
+	 $(LIBS) $(BACKENDLIBS)
 
 # The driver for ghdl.
 ghdl$(exeext): force
diff -urN ghdl-0.29/vhdl/ortho_front.adb ghdl-0.30dev/vhdl/ortho_front.adb
--- ghdl-0.29/vhdl/ortho_front.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/ortho_front.adb	2013-01-30 21:50:36.000000000 +0100
@@ -164,20 +164,23 @@
          end if;
          Action := Action_Anaelab;
          return Decode_Elab_Option (Arg);
-      elsif Opt.all = "-c" then
+      elsif Opt'Length > 14
+        and then Opt (Opt'First .. Opt'First + 13) = "--ghdl-source="
+      then
          if Action /= Action_Anaelab then
             Error_Msg_Option
-              ("-c option allowed only after --anaelab options");
+              ("--ghdl-source option allowed only after --anaelab options");
             return 0;
          end if;
-         if Arg = null then
-            Error_Msg_Option ("filename required after -c");
+         if Arg /= null then
+            Error_Msg_Option ("no argument allowed after --ghdl-source");
             return 0;
          end if;
          declare
             L : Id_Link_Acc;
          begin
-            L := new Id_Link'(Id => Name_Table.Get_Identifier (Arg.all),
+            L := new Id_Link'(Id => Name_Table.Get_Identifier
+                                (Opt (Opt'First + 14 .. Opt'Last)),
                               Link => null);
             if Anaelab_Files = null then
                Anaelab_Files := L;
diff -urN ghdl-0.29/vhdl/ortho_gcc.ads ghdl-0.30dev/vhdl/ortho_gcc.ads
--- ghdl-0.29/vhdl/ortho_gcc.ads	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/ortho_gcc.ads	2013-01-30 21:50:37.000000000 +0100
@@ -426,6 +426,9 @@
 private
    subtype Tree is System.Address;
    NULL_TREE : constant Tree := System.Null_Address;
+
+   subtype Vec_Ptr is System.Address;
+
    type O_Cnode is new Tree;
    type O_Enode is new Tree;
    type O_Lnode is new Tree;
@@ -513,9 +516,17 @@
       Chain : Chain_Constr_Type;
    end record;
 
-   type O_Record_Aggr_List is new O_Aggr_List;
+   type O_Record_Aggr_List is record
+      Atype : Tree;
+      Afield : Tree;
+      Vec : Vec_Ptr;
+   end record;
    pragma Convention (C, O_Record_Aggr_List);
-   type O_Array_Aggr_List is new O_Aggr_List;
+
+   type O_Array_Aggr_List is record
+      Atype : Tree;
+      Vec : Vec_Ptr;
+   end record;
    pragma Convention (C, O_Array_Aggr_List);
 
    type O_Assoc_List is record
diff -urN ghdl-0.29/vhdl/ortho-lang.c ghdl-0.30dev/vhdl/ortho-lang.c
--- ghdl-0.29/vhdl/ortho-lang.c	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/ortho-lang.c	2013-01-30 21:50:37.000000000 +0100
@@ -15,7 +15,7 @@
 #include "opts.h"
 #include "options.h"
 #include "real.h"
-#include "tree-gimple.h"
+#include "tree-iterator.h"
 #include "function.h"
 #include "cgraph.h"
 #include "target.h"
@@ -23,11 +23,16 @@
 #include "tree-pass.h"
 #include "tree-dump.h"
 
+/* TODO:
+ * remove stmt_list_stack, save in if/case/loop block
+ * Re-add -v (if necessary)
+ */
+
 static tree type_for_size (unsigned int precision, int unsignedp);
 
 const int tree_identifier_size = sizeof (struct tree_identifier);
 
-struct binding_level GTY(())
+struct GTY(()) binding_level
 {
   /*  The BIND_EXPR node for this binding.  */
   tree bind;
@@ -56,7 +61,8 @@
 /*  Chain of unused binding levels.  */
 static GTY(()) struct binding_level *old_binding_levels = NULL;
 
-static tree cur_stmts = NULL_TREE;
+/*  Chain of statements currently generated.  */
+static GTY(()) tree cur_stmts = NULL_TREE;
 
 static void
 push_binding (void)
@@ -64,7 +70,7 @@
   struct binding_level *res;
 
   if (old_binding_levels == NULL)
-    res = (struct binding_level *) ggc_alloc (sizeof (struct binding_level));
+    res = ggc_alloc_binding_level ();
   else
     {
       res = old_binding_levels;
@@ -93,7 +99,7 @@
       if (cur_binding_level->first_block == NULL)
 	cur_binding_level->first_block = res->block;
       else
-	TREE_CHAIN (cur_binding_level->last_block) = res->block;
+	BLOCK_CHAIN (cur_binding_level->last_block) = res->block;
       cur_binding_level->last_block = res->block;
 
       BLOCK_SUPERCONTEXT (res->block) = cur_binding_level->block;
@@ -133,22 +139,21 @@
       tree t;
 
       /* Create an artificial var to save the stack pointer.  */
-      tmp_var = build_decl (VAR_DECL, NULL, ptr_type_node);
+      tmp_var = build_decl (input_location, VAR_DECL, NULL, ptr_type_node);
       DECL_ARTIFICIAL (tmp_var) = true;
       DECL_IGNORED_P (tmp_var) = true;
       TREE_USED (tmp_var) = true;
       push_decl (tmp_var);
 
       /* Create the save stmt.  */
-      save_call = build_function_call_expr
-	(implicit_built_in_decls[BUILT_IN_STACK_SAVE], NULL_TREE);
+      save_call = build_call_expr
+	(builtin_decl_implicit (BUILT_IN_STACK_SAVE), 0);
       save = build2 (MODIFY_EXPR, ptr_type_node, tmp_var, save_call);
       TREE_SIDE_EFFECTS (save) = true;
 
       /* Create the restore stmt.  */
-      restore = build_function_call_expr
-	(implicit_built_in_decls[BUILT_IN_STACK_RESTORE],
-	 tree_cons (NULL_TREE, tmp_var, NULL_TREE));
+      restore = build_call_expr
+	(builtin_decl_implicit (BUILT_IN_STACK_RESTORE), 1, tmp_var);
 
       /* Build a try-finally block.
 	 The statement list is the block of current statements.  */
@@ -181,30 +186,29 @@
   return res;
 }
 
-static void
-append_stmt (tree stmt)
-{
-  if (!EXPR_HAS_LOCATION (stmt))
-    SET_EXPR_LOCATION (stmt, input_location);
-  TREE_SIDE_EFFECTS (stmt) = true;
-  append_to_statement_list (stmt, &cur_stmts);
-}
+/* This is a stack of current statement_lists  */
+static GTY(()) VEC_tree_gc * stmt_list_stack;
 
 static void
 push_stmts (tree stmts)
 {
-  TREE_CHAIN (stmts) = cur_stmts;
+  VEC_safe_push (tree, gc, stmt_list_stack, cur_stmts);
   cur_stmts = stmts;
 }
-
+ 
 static void
 pop_stmts (void)
 {
-  tree prev;
+  cur_stmts = VEC_pop (tree, stmt_list_stack);
+}
 
-  prev = cur_stmts;
-  cur_stmts = TREE_CHAIN (prev);
-  TREE_CHAIN (prev) = NULL_TREE;
+static void
+append_stmt (tree stmt)
+{
+  if (!EXPR_HAS_LOCATION (stmt))
+    SET_EXPR_LOCATION (stmt, input_location);
+  TREE_SIDE_EFFECTS (stmt) = true;
+  append_to_statement_list (stmt, &cur_stmts);
 }
 
 static GTY(()) tree top;
@@ -212,22 +216,16 @@
 static GTY(()) tree stack_alloc_function_ptr;
 extern void ortho_fe_init (void);
 
-static int
+static bool
 global_bindings_p (void)
 {
   return cur_binding_level->prev == NULL;
 }
 
-static void
-insert_block (tree b)
-{
-  abort ();
-}
-
 static tree
 pushdecl (tree t)
 {
-  abort ();
+  gcc_unreachable ();
 }
 
 static tree
@@ -253,13 +251,12 @@
   push_binding ();
 
   build_common_tree_nodes (0, 0);
-  size_type_node = type_for_size (GET_MODE_BITSIZE (Pmode), 1);
-  set_sizetype (size_type_node);
-  build_common_tree_nodes_2 (0);
 
-  n = build_decl (TYPE_DECL, get_identifier ("int"), integer_type_node);
+  n = build_decl (input_location,
+                  TYPE_DECL, get_identifier ("int"), integer_type_node);
   push_decl (n);
-  n = build_decl (TYPE_DECL, get_identifier ("char"), char_type_node);
+  n = build_decl (input_location,
+                  TYPE_DECL, get_identifier ("char"), char_type_node);
   push_decl (n);
 
   /* Create alloca builtin.  */
@@ -267,22 +264,26 @@
     tree args_type = tree_cons (NULL_TREE, size_type_node, void_list_node);
     tree func_type = build_function_type (ptr_type_node, args_type);
        
-    implicit_built_in_decls[BUILT_IN_ALLOCA] = builtin_function
-      ("__builtin_alloca", func_type,
-       BUILT_IN_ALLOCA, BUILT_IN_NORMAL, NULL, NULL_TREE);
+    set_builtin_decl
+      (BUILT_IN_ALLOCA,
+       builtin_function
+       ("__builtin_alloca", func_type,
+	BUILT_IN_ALLOCA, BUILT_IN_NORMAL, NULL, NULL_TREE), true);
     
     stack_alloc_function_ptr = build1
       (ADDR_EXPR, 
        build_pointer_type (func_type),
-       implicit_built_in_decls[BUILT_IN_ALLOCA]);
+       builtin_decl_implicit (BUILT_IN_ALLOCA));
   }
 
   {
     tree ptr_ftype = build_function_type (ptr_type_node, NULL_TREE);
 
-    implicit_built_in_decls[BUILT_IN_STACK_SAVE] = builtin_function
-      ("__builtin_stack_save", ptr_ftype,
-       BUILT_IN_STACK_SAVE, BUILT_IN_NORMAL, NULL, NULL_TREE);
+    set_builtin_decl
+      (BUILT_IN_STACK_SAVE,
+       builtin_function
+       ("__builtin_stack_save", ptr_ftype,
+	BUILT_IN_STACK_SAVE, BUILT_IN_NORMAL, NULL, NULL_TREE), true);
   }
 
   {
@@ -292,9 +293,11 @@
       (void_type_node,
        tree_cons (NULL_TREE, ptr_type_node, NULL_TREE));
 
-    implicit_built_in_decls[BUILT_IN_STACK_RESTORE] = builtin_function
-      ("__builtin_stack_restore", ftype_ptr,
-       BUILT_IN_STACK_RESTORE, BUILT_IN_NORMAL, NULL, NULL_TREE);
+    set_builtin_decl
+      (BUILT_IN_STACK_RESTORE,
+       builtin_function
+       ("__builtin_stack_restore", ftype_ptr,
+	BUILT_IN_STACK_RESTORE, BUILT_IN_NORMAL, NULL, NULL_TREE), true);
   }
 
   {
@@ -320,7 +323,7 @@
 }
 
 static unsigned int
-ortho_init_options (unsigned int argc, const char **argv)
+ortho_option_lang_mask (void)
 {
   return CL_vhdl;
 }
@@ -331,14 +334,19 @@
   if (*pfilename == NULL || strcmp (*pfilename, "-") == 0)
     *pfilename = "*stdin*";
 
+  /* Default hook.  */
+  lhd_post_options (pfilename);
+
   /* Run the back-end.  */
   return false;
 }
 
-extern int lang_handle_option (const char *opt, const char *arg);
+extern bool lang_handle_option (const char *opt, const char *arg);
 
-static int
-ortho_handle_option (size_t code, const char *arg, int value)
+static bool
+ortho_handle_option (size_t code, const char *arg, int value, int kind,
+                     location_t loc,
+                     const struct cl_option_handlers *handlers)
 {
   const char *opt;
 
@@ -375,7 +383,7 @@
 extern int lang_parse_file (const char *filename);
 
 static void
-ortho_parse_file (int debug)
+ortho_parse_file (void)
 {
   const char *filename;
 
@@ -389,11 +397,6 @@
 
   if (!lang_parse_file (filename))
     errorcount++;
-  else
-    {
-      cgraph_finalize_compilation_unit ();
-      cgraph_optimize ();
-    }
   linemap_add (line_table, LC_LEAVE, 0, NULL, 1);
 }
 
@@ -436,7 +439,7 @@
 	return true;
 
       default:
-	abort ();
+	gcc_unreachable ();
       }
 }
 
@@ -483,7 +486,7 @@
       return real_zerop (expr) ? f : t;
 
     default:
-      abort ();
+      gcc_unreachable ();
     }
 }
 
@@ -544,8 +547,7 @@
     return error_mark_node;
   if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE || code == VOID_TYPE)
     {
-      abort ();
-      return error_mark_node;
+      gcc_unreachable ();
     }
   if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)
     return fold (convert_to_integer (type, e));
@@ -567,7 +569,7 @@
   if (code == REAL_TYPE)
     return fold (convert_to_real (type, e));
 
-  abort ();
+  gcc_unreachable ();
 }
 
 /* Return a definition for a builtin function named NAME and whose data type
@@ -586,7 +588,8 @@
 		  const char *library_name,
 		  tree attrs ATTRIBUTE_UNUSED)
 {
-  tree decl = build_decl (FUNCTION_DECL, get_identifier (name), type);
+  tree decl = build_decl (input_location,
+                          FUNCTION_DECL, get_identifier (name), type);
   DECL_EXTERNAL (decl) = 1;
   TREE_PUBLIC (decl) = 1;
   if (library_name)
@@ -646,8 +649,8 @@
 #define LANG_HOOKS_INIT ortho_init
 #undef LANG_HOOKS_FINISH
 #define LANG_HOOKS_FINISH ortho_finish
-#undef LANG_HOOKS_INIT_OPTIONS
-#define LANG_HOOKS_INIT_OPTIONS ortho_init_options
+#undef LANG_HOOKS_OPTION_LANG_MASK
+#define LANG_HOOKS_OPTION_LANG_MASK ortho_option_lang_mask
 #undef LANG_HOOKS_HANDLE_OPTION
 #define LANG_HOOKS_HANDLE_OPTION ortho_handle_option
 #undef LANG_HOOKS_POST_OPTIONS
@@ -678,60 +681,31 @@
 #undef LANG_HOOKS_GETDECLS
 #define LANG_HOOKS_GETDECLS lhd_return_null_tree_v
 
-const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;
-
-/* Tree code classes.  */
-
-#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,
-
-const enum tree_code_class tree_code_type[] = {
-#include "tree.def"
-  'x'
-};
-#undef DEFTREECODE
-
-/* Table indexed by tree code giving number of expression
-   operands beyond the fixed part of the node structure.
-   Not used for types or decls.  */
-
-#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) LENGTH,
-
-const unsigned char tree_code_length[] = {
-#include "tree.def"
-  0
-};
-#undef DEFTREECODE
-
-#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) NAME,
-const char * const tree_code_name[] = {
-#include "tree.def"
-  "@@dummy"
-};
-#undef DEFTREECODE
+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;
 
-union lang_tree_node 
-  GTY((desc ("0"),
-       chain_next ("(union lang_tree_node *) GENERIC_NEXT (&%h.generic)")))
+union GTY((desc ("0"),
+	   chain_next ("CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL")))
+  lang_tree_node
 {
-  union tree_node GTY ((tag ("0"))) generic;
+  union tree_node GTY((tag ("0"),
+		       desc ("tree_node_structure (&%h)"))) generic;
 };
 
-struct lang_decl GTY(())
-{
-  char dummy;
-};
+/* GHDL does not use the lang_decl and lang_type.
 
-struct lang_type GTY (())
-{
-  char dummy;
-};
+   FIXME: the variable_size annotation here is needed because these types are
+   variable-sized in some other front-ends.  Due to gengtype deficiency, the
+   GTY options of such types have to agree across all front-ends.  */
 
-struct language_function GTY (())
+struct GTY((variable_size)) lang_type { char dummy; };
+struct GTY((variable_size)) lang_decl { char dummy; };
+
+struct GTY(()) language_function
 {
   char dummy;
 };
 
-struct chain_constr_type
+struct GTY(()) chain_constr_type
 {
   tree first;
   tree last;
@@ -749,8 +723,7 @@
 {
   if (constr->first == NULL_TREE)
     {
-      if (constr->last != NULL_TREE)
-	abort ();
+      gcc_assert (constr->last == NULL_TREE);
       constr->first = el;
     }
   else
@@ -758,7 +731,7 @@
   constr->last = el;
 }
 
-struct list_constr_type
+struct GTY(()) list_constr_type
 {
   tree first;
   tree last;
@@ -855,8 +828,7 @@
   enum tree_code code;
 
   left_type = TREE_TYPE (left);
-  if (left_type != TREE_TYPE (right))
-    abort ();
+  gcc_assert (left_type == TREE_TYPE (right));
 
   switch (kind)
     {
@@ -882,10 +854,8 @@
 tree
 new_compare_op (enum ON_op_kind kind, tree left, tree right, tree ntype)
 {
-  if (TREE_CODE (ntype) != BOOLEAN_TYPE)
-    abort ();
-  if (TREE_TYPE (left) != TREE_TYPE (right))
-    abort ();
+  gcc_assert (TREE_CODE (ntype) == BOOLEAN_TYPE);
+  gcc_assert (TREE_TYPE (left) == TREE_TYPE (right));
   return build2 (ON_op_to_TREE_CODE[kind], ntype, left, right);
 }
 
@@ -947,7 +917,7 @@
   else if (val_code == REAL_TYPE && rtype_code == REAL_TYPE)
     code = NOP_EXPR;
   else
-    abort ();
+    gcc_unreachable ();
 
   return build1 (code, rtype, val);
 }
@@ -956,15 +926,14 @@
 new_alloca (tree rtype, tree size)
 {
   tree res;
-  tree args;
 
   /* Must save stack except when at function level.  */
   if (cur_binding_level->prev != NULL
       && cur_binding_level->prev->prev != NULL)
     cur_binding_level->save_stack = 1;
 
-  args = tree_cons (NULL_TREE, fold_convert (size_type_node, size), NULL_TREE);
-  res = build_call_list (ptr_type_node, stack_alloc_function_ptr, args);
+  res = build_call_nary (ptr_type_node, stack_alloc_function_ptr,
+                         1, fold_convert (size_type_node, size));
   return fold_convert (rtype, res);
 }
 
@@ -976,11 +945,7 @@
   HOST_WIDE_INT hi;
 
   lo = value;
-  if (sizeof (HOST_WIDE_INT) == sizeof (long long))
-    hi = value >> (8 * sizeof (HOST_WIDE_INT) - 1);
-  else
-    hi = value >> (8 * sizeof (HOST_WIDE_INT));
-
+  hi = (value >> 1) >> (8 * sizeof (HOST_WIDE_INT) - 1);
   res = build_int_cst_wide (ltype, lo, hi);
   return res;
 }
@@ -993,11 +958,7 @@
   unsigned HOST_WIDE_INT hi;
 
   lo = value;
-  if (sizeof (HOST_WIDE_INT) == sizeof (long long))
-    hi = 0;
-  else
-    hi = value >> (8 * sizeof (HOST_WIDE_INT));
-
+  hi = (value >> 1) >> (8 * sizeof (HOST_WIDE_INT) - 1);
   res = build_int_cst_wide (ltype, lo, hi);
   return res;
 }
@@ -1028,11 +989,7 @@
   
   s = ldexp (frac, 60);
   lo = s;
-  if (sizeof (HOST_WIDE_INT) == sizeof (long long))
-    hi = s >> (8 * sizeof (HOST_WIDE_INT) - 1);
-  else
-    hi = s >> (8 * sizeof (HOST_WIDE_INT));
-
+  hi = (s >> 1) >> (8 * sizeof (HOST_WIDE_INT) - 1);
   res = build_int_cst_wide (long_integer_type_node, lo, hi);
   REAL_VALUE_FROM_INT (r_sign, lo, hi, DFmode);
   real_2expN (&r_exp, ex - 60, DFmode);
@@ -1041,7 +998,7 @@
   return res;
 }
 
-struct o_element_list
+struct GTY(()) o_element_list
 {
   tree res;
   struct chain_constr_type chain;
@@ -1075,7 +1032,8 @@
 {
   tree res;
 
-  res = build_decl (FIELD_DECL, ident, etype);
+  res = build_decl (input_location,
+                    FIELD_DECL, ident, etype);
   DECL_CONTEXT (res) = list->res;
   chain_append (&list->chain, res);
   *el = res;
@@ -1104,7 +1062,6 @@
     }
 }
 
-
 void
 start_union_type (struct o_element_list *elements)
 {
@@ -1162,7 +1119,7 @@
       res = make_node (POINTER_TYPE);
       TREE_TYPE (res) = NULL_TREE;
       /* Seems necessary.  */
-      TYPE_MODE (res) = Pmode;
+      SET_TYPE_MODE (res, Pmode);
       layout_type (res);
       return res;
     }
@@ -1173,9 +1130,8 @@
 void
 finish_access_type (tree atype, tree dtype)
 {
-  if (TREE_CODE (atype) != POINTER_TYPE
-      || TREE_TYPE (atype) != NULL_TREE)
-    abort ();
+  gcc_assert (TREE_CODE (atype) == POINTER_TYPE
+	      && TREE_TYPE (atype) == NULL_TREE);
 
   TREE_TYPE (atype) = dtype;
 }
@@ -1260,62 +1216,78 @@
 {
   *res = list->res;
   TYPE_VALUES (*res) = list->chain.first;
-  TYPE_MIN_VALUE (*res) = TREE_VALUE (list->chain.first);
-  TYPE_MAX_VALUE (*res) = TREE_VALUE (list->chain.last);
   TYPE_UNSIGNED (*res) = 1;
   TYPE_PRECISION (*res) = list->size;
+  set_min_and_max_values_for_integral_type (*res, list->size, 1);
   layout_type (*res);
 }
 
-struct o_record_aggr_list
+struct GTY(()) o_record_aggr_list
 {
+  /* Type of the record.  */
   tree atype;
-  struct chain_constr_type chain;
+  /* Type of the next field to be added.  */
+  tree field;
+  /* Vector of elements.  */
+  VEC(constructor_elt,gc) *elts;
 };
 
 void
 start_record_aggr (struct o_record_aggr_list *list, tree atype)
 {
   list->atype = atype;
-  chain_init (&list->chain);
+  list->field = TYPE_FIELDS (atype);
+  list->elts = VEC_alloc (constructor_elt, gc, fields_length (atype));
+
 }
 
 void
 new_record_aggr_el (struct o_record_aggr_list *list, tree value)
 {
-  chain_append (&list->chain, build_tree_list (NULL_TREE, value));
+  CONSTRUCTOR_APPEND_ELT (list->elts, list->field, value);
+  list->field = TREE_CHAIN (list->field);
 }
 
 void
 finish_record_aggr (struct o_record_aggr_list *list, tree *res)
 {
-  *res = build_constructor_from_list (list->atype, list->chain.first);
+  *res = build_constructor (list->atype, list->elts);
 }
  
 
-struct o_array_aggr_list
+struct GTY(()) o_array_aggr_list
 {
   tree atype;
-  struct chain_constr_type chain;
+  /* Vector of elements.  */
+  VEC(constructor_elt,gc) *elts;
 };
 
 void
 start_array_aggr (struct o_array_aggr_list *list, tree atype)
 {
+  tree nelts;
+  unsigned HOST_WIDE_INT n;
+
   list->atype = atype;
-  chain_init (&list->chain);
+  list->elts = NULL;
+
+  nelts = array_type_nelts (atype);
+  gcc_assert (nelts != NULL_TREE && host_integerp (nelts, 1));
+
+  n = tree_low_cst (nelts, 1) + 1;
+  list->elts = VEC_alloc (constructor_elt, gc, n);
 }
 
 void
 new_array_aggr_el (struct o_array_aggr_list *list, tree value)
 {
-  chain_append (&list->chain, build_tree_list (NULL_TREE, value));
+  CONSTRUCTOR_APPEND_ELT (list->elts, NULL_TREE, value);
 }
  
 void
 finish_array_aggr (struct o_array_aggr_list *list, tree *res)
 {
-  *res = build_constructor_from_list (list->atype, list->chain.first);
+  *res = build_constructor (list->atype, list->elts);
 }
 
 
@@ -1349,8 +1321,7 @@
 
   /*  *((RES_TYPE *)(&ARR[INDEX]))
       convert ARR to a pointer, add index, and reconvert to array ?  */
-  if (TREE_CODE (res_type) != ARRAY_TYPE)
-    abort ();
+  gcc_assert (TREE_CODE (res_type) == ARRAY_TYPE);
 
   ortho_mark_addressable (arr);
   return build4 (ARRAY_RANGE_REF, res_type, arr, index, NULL_TREE, NULL_TREE);
@@ -1372,8 +1343,7 @@
 {
   tree res;
 
-  if (TREE_CODE (TREE_TYPE (rec)) != RECORD_TYPE)
-    abort ();
+  gcc_assert (TREE_CODE (TREE_TYPE (rec)) == RECORD_TYPE);
 
   res = build3 (COMPONENT_REF, TREE_TYPE (el), rec, el, NULL_TREE);
   return res;
@@ -1385,8 +1355,7 @@
   tree acc_type;
 
   acc_type = TREE_TYPE (acc);
-  if (TREE_CODE (acc_type) != POINTER_TYPE)
-    abort ();
+  gcc_assert (TREE_CODE (acc_type) == POINTER_TYPE);
 
   return build1 (INDIRECT_REF, TREE_TYPE (acc_type), acc);
 }
@@ -1400,18 +1369,14 @@
   tree res;
 
   off = DECL_FIELD_OFFSET (field);
-  if (!host_integerp (off, 1))
-    {
-      /*  The offset must be a constant.  */
-      abort ();
-    }
+
+  /*  The offset must be a constant.  */
+  gcc_assert (host_integerp (off, 1));
 
   bit_off = DECL_FIELD_BIT_OFFSET (field);
-  if (!host_integerp (bit_off, 1))
-    {
-      /*  The offset must be a constant.  */
-      abort ();
-    }
+
+  /*  The offset must be a constant.  */
+  gcc_assert (host_integerp (bit_off, 1));
 
   pos = TREE_INT_CST_LOW (off)
         + (TREE_INT_CST_LOW (bit_off) / BITS_PER_UNIT);
@@ -1574,7 +1539,7 @@
   tree decl;
 
   TYPE_NAME (atype) = ident;
-  decl = build_decl (TYPE_DECL, ident, atype);
+  decl = build_decl (input_location, TYPE_DECL, ident, atype);
   TYPE_STUB_DECL (atype) = decl;
   push_decl (decl);
   /*
@@ -1623,14 +1588,14 @@
 {
   tree cst;
 
-  cst = build_decl (VAR_DECL, ident, atype);
+  cst = build_decl (input_location, VAR_DECL, ident, atype);
   set_storage (cst, storage);
   TREE_READONLY (cst) = 1;
   push_decl (cst);
   switch (storage)
     {
     case o_storage_local:
-      abort ();
+      gcc_unreachable ();
     case o_storage_external:
       /*  We are at top level if Current_Function_Decl is null.  */
       rest_of_decl_compilation
@@ -1663,7 +1628,7 @@
 {
   tree var;
 
-  var = build_decl (VAR_DECL, ident, atype);
+  var = build_decl (input_location, VAR_DECL, ident, atype);
   if (current_function_decl != NULL_TREE)
     {    
       /*  Local variable. */
@@ -1682,7 +1647,7 @@
   *res = var;
 }
 
-struct o_inter_list
+struct GTY(()) o_inter_list
 {
   tree ident;
   enum o_storage storage;
@@ -1726,7 +1691,7 @@
 {
   tree r;
 
-  r = build_decl (PARM_DECL, ident, atype);
+  r = build_decl (input_location, PARM_DECL, ident, atype);
   /* DECL_CONTEXT (Res, Xxx); */
 
   /*  Do type conversion: convert boolean and enums to int  */
@@ -1746,10 +1711,6 @@
   *res = r;
 }
 
-/*  Current function nest level, or the number of parents.  */
-/* static int function_nest_level; */
-
-
 void
 finish_subprogram_decl (struct o_inter_list *interfaces, tree *res)
 {
@@ -1762,7 +1723,7 @@
      is known not be have variables arguments.  */
   ortho_list_append (&interfaces->param_list, void_type_node);
 
-  decl = build_decl (FUNCTION_DECL, interfaces->ident,
+  decl = build_decl (input_location, FUNCTION_DECL, interfaces->ident,
 		     build_function_type (interfaces->rtype,
 					  interfaces->param_list.first));
   DECL_SOURCE_LOCATION (decl) = input_location;
@@ -1784,7 +1745,8 @@
 
   /*  Declare the result.
       FIXME: should be moved in start_function_body. */
-  result = build_decl (RESULT_DECL, NULL_TREE, interfaces->rtype);
+  result = build_decl (input_location,
+                       RESULT_DECL, NULL_TREE, interfaces->rtype);
   DECL_RESULT (decl) = result;
   DECL_CONTEXT (result) = decl;
 
@@ -1811,8 +1773,7 @@
 void
 start_subprogram_body (tree func)
 {
-  if (current_function_decl != DECL_CONTEXT (func))
-    abort ();
+  gcc_assert (current_function_decl == DECL_CONTEXT (func));
   current_function_decl = func;
 
   /* The function is not anymore external.  */
@@ -1842,19 +1803,11 @@
   /* Store the end of the function.  */
   cfun->function_end_locus = input_location;
   
-  /* This function is being processed in whole-function mode.  */
-  /* cfun->x_whole_function_mode_p = 1; */
-
-  gimplify_function_tree (func);
-
-  /* Dump the genericized tree IR.
-     Enabled by -fdump-tree-gimple.  */
-  dump_function (TDI_generic, func);
 
   parent = DECL_CONTEXT (func);
 
   if (parent != NULL)
-    cgraph_node (func);
+    cgraph_get_create_node (func);
   else
     cgraph_finalize_function (func, false);
 
@@ -1887,31 +1840,31 @@
 }
 
 
-struct o_assoc_list
+struct GTY(()) o_assoc_list
 {
   tree subprg;
-  struct list_constr_type list;
+  VEC(tree,gc) *vec;
 };
 
 void
 start_association (struct o_assoc_list *assocs, tree subprg)
 {
   assocs->subprg = subprg;
-  list_init (&assocs->list);
+  assocs->vec = NULL;
 }
 
 void
 new_association (struct o_assoc_list *assocs, tree val)
 {
-  ortho_list_append (&assocs->list, val);
+  VEC_safe_push (tree, gc, assocs->vec, val);
 }
 
 tree
 new_function_call (struct o_assoc_list *assocs)
 {
-  return build_call_list (TREE_TYPE (TREE_TYPE (assocs->subprg)),
-			  build_function_ptr (assocs->subprg),
-			  assocs->list.first);
+  return build_call_vec (TREE_TYPE (TREE_TYPE (assocs->subprg)),
+                         build_function_ptr (assocs->subprg),
+                         assocs->vec);
 }
 
 void
@@ -1919,9 +1872,9 @@
 {
   tree res;
 
-  res = build_call_list (TREE_TYPE (TREE_TYPE (assocs->subprg)),
-			 build_function_ptr (assocs->subprg),
-			 assocs->list.first);
+  res = build_call_vec (TREE_TYPE (TREE_TYPE (assocs->subprg)),
+                        build_function_ptr (assocs->subprg),
+                        assocs->vec);
   TREE_SIDE_EFFECTS (res) = 1;
   append_stmt (res);
 }
@@ -1962,7 +1915,7 @@
 }
 
 
-struct o_if_block
+struct GTY(()) o_if_block
 {
   tree stmt;
 };
@@ -2012,13 +1965,7 @@
 }
 
 
-struct o_loop_block
-{
-  tree beg_label;
-  tree end_label;
-};
-
-struct o_snode
+struct GTY(()) o_snode
 {
   tree beg_label;
   tree end_label;
@@ -2030,7 +1977,7 @@
 {
   tree res;
 
-  res = build_decl (LABEL_DECL, NULL_TREE, void_type_node);
+  res = build_decl (input_location, LABEL_DECL, NULL_TREE, void_type_node);
   DECL_CONTEXT (res) = current_function_decl;
   DECL_ARTIFICIAL (res) = 1;
   return res;
@@ -2086,7 +2033,7 @@
   append_stmt (stmt);
 }
 
-struct o_case_block
+struct GTY(()) o_case_block
 {
   tree end_label;
   int add_break;
@@ -2125,8 +2072,8 @@
 {
   tree stmt;
   
-  stmt = build3 (CASE_LABEL_EXPR, void_type_node,
-		 expr, NULL_TREE, create_artificial_label ());
+  stmt = build_case_label
+    (expr, NULL_TREE, create_artificial_label (input_location));
   append_stmt (stmt);
 }
 
@@ -2135,8 +2082,8 @@
 {
   tree stmt;
 
-  stmt = build3 (CASE_LABEL_EXPR, void_type_node,
-		 low, high, create_artificial_label ());
+  stmt = build_case_label
+    (low, high, create_artificial_label (input_location));
   append_stmt (stmt);
 }
 
@@ -2145,8 +2092,8 @@
 {
   tree stmt;
 
-  stmt = build3 (CASE_LABEL_EXPR, void_type_node,
-		 NULL_TREE, NULL_TREE, create_artificial_label ());
+  stmt = build_case_label
+    (NULL_TREE, NULL_TREE, create_artificial_label (input_location));
   append_stmt (stmt);
 }
 
diff -urN ghdl-0.29/vhdl/sa_bools.adb ghdl-0.30dev/vhdl/sa_bools.adb
--- ghdl-0.29/vhdl/sa_bools.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/sa_bools.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-with PSL.Errors; use PSL.Errors;
-with Name_Table;
-with Types; use Types;
-with Ada.Text_IO;
-
-package body Sa_Bools is
-   function Sem (N : Node) return Node is
-   begin
-      case Get_Kind (N) is
-         when N_Or_Bool
-           | N_And_Bool =>
-            Set_Left (N, Sem (Get_Left (N)));
-            Set_Right (N, Sem (Get_Right (N)));
-            return N;
-         when N_Not_Bool =>
-            Set_Boolean (N, Sem (Get_Boolean (N)));
-            return N;
-         when N_Name =>
-            declare
-               use Name_Table;
-               Id : constant Name_Id := Get_Identifier (N);
-               Name : Node;
-            begin
-               Name := Node (Get_Info (Id));
-               if Name /= Null_Node then
-                  return Name;
-               end if;
-               Name := Create_Node (N_HDL_Expr);
-               Set_HDL_Node (Name, Int32 (Id));
-               Set_Info (Id, Int32 (Name));
-               return Name;
-            end;
-         when others =>
-            Error_Kind ("sem", N);
-      end case;
-   end Sem;
-
-   procedure Print_HDL_Expr (N : Node) is
-   begin
-      Ada.Text_IO.Put (Image (Name_Id (Get_HDL_Node (N))));
-   end Print_HDL_Expr;
-end Sa_Bools;
diff -urN ghdl-0.29/vhdl/sa_bools.ads ghdl-0.30dev/vhdl/sa_bools.ads
--- ghdl-0.29/vhdl/sa_bools.ads	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/sa_bools.ads	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-with PSL.Nodes; use PSL.Nodes;
-
-package Sa_Bools is
-   function Sem (N : Node) return Node;
-
-   procedure Print_HDL_Expr (N : Node);
-end Sa_Bools;
-
diff -urN ghdl-0.29/vhdl/sem_assocs.adb ghdl-0.30dev/vhdl/sem_assocs.adb
--- ghdl-0.29/vhdl/sem_assocs.adb	2009-12-29 08:07:07.000000000 +0100
+++ ghdl-0.30dev/vhdl/sem_assocs.adb	2013-01-30 21:50:36.000000000 +0100
@@ -467,6 +467,7 @@
       Sub : Iir;
       Formal_Object : Iir;
    begin
+      --  Recurse.
       Formal_Object := Name_To_Object (Formal);
       case Get_Kind (Formal_Object) is
          when Iir_Kind_Indexed_Name
@@ -518,6 +519,7 @@
       end case;
    end Add_Individual_Association_1;
 
+   --  Insert ASSOC into the tree of individual assoc rooted by IASSOC.
    procedure Add_Individual_Association (Iassoc : Iir; Assoc : Iir)
    is
       Formal : Iir;
diff -urN ghdl-0.29/vhdl/version.ads ghdl-0.30dev/vhdl/version.ads
--- ghdl-0.29/vhdl/version.ads	2010-01-09 15:07:10.000000000 +0100
+++ ghdl-0.30dev/vhdl/version.ads	2013-01-30 21:50:36.000000000 +0100
@@ -1,5 +1,5 @@
 package Version is
    Ghdl_Release : constant String :=
-      "GHDL 0.29 (20100109) [Sokcho edition]";
-   Ghdl_Ver : constant String := "0.29";
+      "GHDL 0.30dev (20100112) [Sokcho edition]";
+   Ghdl_Ver : constant String := "0.30dev";
 end Version;
